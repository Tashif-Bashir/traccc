\hypertarget{namespacetraccc_1_1device}{}\doxysection{traccc\+::device Namespace Reference}
\label{namespacetraccc_1_1device}\index{traccc::device@{traccc::device}}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespacetraccc_1_1device_1_1details}{details}}
\item 
 \mbox{\hyperlink{namespacetraccc_1_1device_1_1experimental}{experimental}}
\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classtraccc_1_1device_1_1container__d2h__copy__alg}{container\+\_\+d2h\+\_\+copy\+\_\+alg}}
\item 
class \mbox{\hyperlink{classtraccc_1_1device_1_1container__h2d__copy__alg}{container\+\_\+h2d\+\_\+copy\+\_\+alg}}
\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1device__doublet}{device\+\_\+doublet}}
\begin{DoxyCompactList}\small\item\em Doublet of middle-\/bottom or middle-\/top spacepoints. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1device__triplet}{device\+\_\+triplet}}
\begin{DoxyCompactList}\small\item\em Triplets of bottom, middle and top spacepoints. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1doublet__counter}{doublet\+\_\+counter}}
\begin{DoxyCompactList}\small\item\em Number of doublets for one specific middle spacepoint. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1finding__global__counter}{finding\+\_\+global\+\_\+counter}}
\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1prefix__sum__buffer}{prefix\+\_\+sum\+\_\+buffer}}
\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1seeding__global__counter}{seeding\+\_\+global\+\_\+counter}}
\begin{DoxyCompactList}\small\item\em Total number of doublets and triplets found in seeding. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1triplet__counter}{triplet\+\_\+counter}}
\begin{DoxyCompactList}\small\item\em Number of triplets for one specific Mid-\/\+Bottom Doublet. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structtraccc_1_1device_1_1triplet__counter__spM}{triplet\+\_\+counter\+\_\+spM}}
\begin{DoxyCompactList}\small\item\em Number of triplets for one specific middle spacepoint. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef thrust\+::pair$<$ std\+::size\+\_\+t, std\+::size\+\_\+t $>$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Type for the individual elements in the prefix sum vector. \end{DoxyCompactList}\item 
typedef vecmem\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$ \mbox{\hyperlink{namespacetraccc_1_1device_aa455dcfea1cafcf634e98d29957158c1}{prefix\+\_\+sum\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Convenience type definition for the return value of the helper function. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\+\_\+sum\+\_\+size\+\_\+t}} = vecmem\+::data\+::vector\+\_\+view$<$ int $>$\+::size\+\_\+type
\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_a1c67d5b48697c4ad899f28ae69120e33}{prefix\+\_\+sum\+\_\+buffer\+\_\+t}} = \mbox{\hyperlink{structtraccc_1_1device_1_1prefix__sum__buffer}{prefix\+\_\+sum\+\_\+buffer}}
\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_a14889993c5b104c16822c9ac949b3fa6}{device\+\_\+doublet\+\_\+collection\+\_\+types}} = \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$ \mbox{\hyperlink{structtraccc_1_1device_1_1device__doublet}{device\+\_\+doublet}} $>$
\begin{DoxyCompactList}\small\item\em Declare all device doublet collection types. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_abb2c4cc2cf52bc55a5d99d90145dccb6}{device\+\_\+triplet\+\_\+collection\+\_\+types}} = \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$ \mbox{\hyperlink{structtraccc_1_1device_1_1device__triplet}{device\+\_\+triplet}} $>$
\begin{DoxyCompactList}\small\item\em Declare all device triplet collection types. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_aad75aaaae6cf52b2ea760947d7832254}{doublet\+\_\+counter\+\_\+collection\+\_\+types}} = \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$ \mbox{\hyperlink{structtraccc_1_1device_1_1doublet__counter}{doublet\+\_\+counter}} $>$
\begin{DoxyCompactList}\small\item\em Declare all doublet counter collection types. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_a2f7630c49e9c5a3d23245f542526f4f0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types}} = \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$ \mbox{\hyperlink{structtraccc_1_1device_1_1triplet__counter__spM}{triplet\+\_\+counter\+\_\+spM}} $>$
\begin{DoxyCompactList}\small\item\em Declare all triplet counter spM collection types. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespacetraccc_1_1device_a07a09a5bd10fd62d71ec0a77079b9b07}{triplet\+\_\+counter\+\_\+collection\+\_\+types}} = \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$ \mbox{\hyperlink{structtraccc_1_1device_1_1triplet__counter}{triplet\+\_\+counter}} $>$
\begin{DoxyCompactList}\small\item\em Declare all triplet counter collection types. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a560c561636e8700675394f3f5a7d7e5d}{aggregate\+\_\+cluster}} (const \mbox{\hyperlink{structtraccc_1_1collection__types_a2c17f74f33da865b1fb58c83e44ecb71}{cell\+\_\+collection\+\_\+types\+::const\+\_\+device}} \&cells, const \mbox{\hyperlink{structtraccc_1_1collection__types_a2c17f74f33da865b1fb58c83e44ecb71}{cell\+\_\+module\+\_\+collection\+\_\+types\+::const\+\_\+device}} \&modules, const vecmem\+::data\+::vector\+\_\+view$<$ unsigned short $>$ f\+\_\+view, const unsigned int start, const unsigned int end, const unsigned short cid, \mbox{\hyperlink{structtraccc_1_1measurement}{measurement}} \&out, vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$ cell\+\_\+links, const unsigned int link)
\item 
{\footnotesize template$<$typename barrier\+\_\+t $>$ }\\\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a581cd4e1e686b1e742185eac2da41369}{ccl\+\_\+kernel}} (const index\+\_\+t thread\+Id, const index\+\_\+t blck\+Dim, const unsigned int block\+Id, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{cell\+\_\+collection\+\_\+types\+::const\+\_\+view}} cells\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{cell\+\_\+module\+\_\+collection\+\_\+types\+::const\+\_\+view}} modules\+\_\+view, const index\+\_\+t max\+\_\+cells\+\_\+per\+\_\+partition, const index\+\_\+t target\+\_\+cells\+\_\+per\+\_\+partition, unsigned int \&partition\+\_\+start, unsigned int \&partition\+\_\+end, unsigned int \&outi, index\+\_\+t $\ast$f, index\+\_\+t $\ast$gf, barrier\+\_\+t \&barrier, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{measurement\+\_\+collection\+\_\+types\+::view}} measurements\+\_\+view, unsigned int \&measurement\+\_\+count, vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$ cell\+\_\+links)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_ad06299bae21c8e751058d3c70ee6a857}{form\+\_\+spacepoints}} (const std\+::size\+\_\+t global\+Index, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}} measurements\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{cell\+\_\+module\+\_\+collection\+\_\+types\+::const\+\_\+view}} modules\+\_\+view, const unsigned int measurement\+\_\+count, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{spacepoint\+\_\+collection\+\_\+types\+::view}} spacepoints\+\_\+view)
\item 
{\footnotesize template$<$typename barrier\+\_\+t $>$ }\\\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a2fc626e715c5d48a0d3261d70d479dd5}{fast\+\_\+sv\+\_\+1}} (index\+\_\+t $\ast$f, index\+\_\+t $\ast$gf, unsigned char adjc\mbox{[}M\+A\+X\+\_\+\+C\+E\+L\+L\+S\+\_\+\+P\+E\+R\+\_\+\+T\+H\+R\+E\+AD\mbox{]}, index\+\_\+t adjv\mbox{[}M\+A\+X\+\_\+\+C\+E\+L\+L\+S\+\_\+\+P\+E\+R\+\_\+\+T\+H\+R\+E\+AD\mbox{]}\mbox{[}8\mbox{]}, const index\+\_\+t tid, const index\+\_\+t blck\+Dim, barrier\+\_\+t \&barrier)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} bool \mbox{\hyperlink{namespacetraccc_1_1device_a32c38f509eef5398c63cc66721db1a83}{is\+\_\+adjacent}} (\mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}} ac0, \mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}} ac1, \mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}} bc0, \mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}} bc1)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_ab8368c09597104f9b3fecf98b4a1111d}{reduce\+\_\+problem\+\_\+cell}} (const \mbox{\hyperlink{structtraccc_1_1collection__types_a2c17f74f33da865b1fb58c83e44ecb71}{cell\+\_\+collection\+\_\+types\+::const\+\_\+device}} \&cells, const unsigned short cid, const unsigned int start, const unsigned int end, unsigned char \&adjc, unsigned short adjv\mbox{[}8\mbox{]})
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a7c2b528a06357f0ac89eae726d2b31ca}{fill\+\_\+prefix\+\_\+sum}} (const std\+::size\+\_\+t global\+Index, const vecmem\+::data\+::vector\+\_\+view$<$ const \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&sizes\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$ ps\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a95b39033664ff24e9b2f42ef43041ad0}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+ST}} \mbox{\hyperlink{namespacetraccc_1_1device_a1c67d5b48697c4ad899f28ae69120e33}{prefix\+\_\+sum\+\_\+buffer\+\_\+t}} \mbox{\hyperlink{namespacetraccc_1_1device_a782823d57c341df346a3589010537dbf}{make\+\_\+prefix\+\_\+sum\+\_\+buffer}} (const std\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&sizes, vecmem\+::copy \&copy, const \mbox{\hyperlink{structtraccc_1_1memory__resource}{traccc\+::memory\+\_\+resource}} \&mr)
\item 
{\footnotesize template$<$typename detector\+\_\+t $>$ }\\\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_acd5f48af899ba8e1b750fd5fd7d46c46}{apply\+\_\+interaction}} (std\+::size\+\_\+t global\+Index, typename detector\+\_\+t\+::view\+\_\+type det\+\_\+data, vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ detray\+::intersection2D$<$ typename detector\+\_\+t\+::surface\+\_\+type, typename detector\+\_\+t\+::transform3 $>$$>$ nav\+\_\+candidates\+\_\+buffer, const int n\+\_\+params, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}} params\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a125de08cb9b6520cb3516fe95c2544a9}{build\+\_\+tracks}} (std\+::size\+\_\+t global\+Index, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}} measurements\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}} seeds\+\_\+view, vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ const \mbox{\hyperlink{structtraccc_1_1candidate__link}{candidate\+\_\+link}} $>$ links\+\_\+view, vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ const unsigned int $>$ param\+\_\+to\+\_\+link\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ const typename \mbox{\hyperlink{structtraccc_1_1candidate__link_a43e4355337d1d689215e7a0c69b86636}{candidate\+\_\+link\+::link\+\_\+index\+\_\+type}} $>$ tips\+\_\+view, \mbox{\hyperlink{structtraccc_1_1container__types_a3344afd1f08f09bcec6d7206d380b26c}{track\+\_\+candidate\+\_\+container\+\_\+types\+::view}} track\+\_\+candidates\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a2875a7c6e478ac6bc7a5cc80dc49dcd4}{count\+\_\+measurements}} (std\+::size\+\_\+t global\+Index, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}} params\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ const detray\+::geometry\+::barcode $>$ barcodes\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ const unsigned int $>$ upper\+\_\+bounds\+\_\+view, const unsigned int n\+\_\+in\+\_\+params, vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$ n\+\_\+measurements\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$ ref\+\_\+meas\+\_\+idx\+\_\+view, unsigned int \&n\+\_\+measurements\+\_\+sum)
\item 
{\footnotesize template$<$typename detector\+\_\+t , typename config\+\_\+t $>$ }\\\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a5a0635de6424316c6518818af669c01a}{find\+\_\+tracks}} (std\+::size\+\_\+t global\+Index, const config\+\_\+t cfg, typename detector\+\_\+t\+::view\+\_\+type det\+\_\+data, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}} measurements\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}} in\+\_\+params\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ const unsigned int $>$ n\+\_\+measurements\+\_\+prefix\+\_\+sum\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ const unsigned int $>$ ref\+\_\+meas\+\_\+idx\+\_\+view, const unsigned int step, const unsigned int \&n\+\_\+max\+\_\+candidates, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}} out\+\_\+params\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ \mbox{\hyperlink{structtraccc_1_1candidate__link}{candidate\+\_\+link}} $>$ links\+\_\+view, unsigned int \&n\+\_\+candidates)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_aee8f3ca7cc59d443151e6da536f1fb36}{make\+\_\+barcode\+\_\+sequence}} (std\+::size\+\_\+t global\+Index, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}} uniques\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ detray\+::geometry\+::barcode $>$ barcodes\+\_\+view)
\item 
{\footnotesize template$<$typename propagator\+\_\+t , typename bfield\+\_\+t , typename config\+\_\+t $>$ }\\\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a5fbc8641d583065ed1ebc98503d01f10}{propagate\+\_\+to\+\_\+next\+\_\+surface}} (std\+::size\+\_\+t global\+Index, const config\+\_\+t cfg, typename propagator\+\_\+t\+::detector\+\_\+type\+::view\+\_\+type det\+\_\+data, bfield\+\_\+t field\+\_\+data, vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ typename propagator\+\_\+t\+::intersection\+\_\+type $>$ nav\+\_\+candidates\+\_\+buffer, \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}} in\+\_\+params\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ const \mbox{\hyperlink{structtraccc_1_1candidate__link}{candidate\+\_\+link}} $>$ links\+\_\+view, const unsigned int step, const unsigned int \&n\+\_\+in\+\_\+params, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}} out\+\_\+params\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$ param\+\_\+to\+\_\+link\+\_\+view, vecmem\+::data\+::vector\+\_\+view$<$ typename \mbox{\hyperlink{structtraccc_1_1candidate__link_a43e4355337d1d689215e7a0c69b86636}{candidate\+\_\+link\+::link\+\_\+index\+\_\+type}} $>$ tips\+\_\+view, unsigned int \&n\+\_\+out\+\_\+params)
\item 
{\footnotesize template$<$typename fitter\+\_\+t , typename detector\+\_\+view\+\_\+t $>$ }\\\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a97659978710a9e2d389c05b9ee4397ae}{fit}} (std\+::size\+\_\+t global\+Index, detector\+\_\+view\+\_\+t det\+\_\+data, const typename fitter\+\_\+t\+::bfield\+\_\+type field\+\_\+data, const typename fitter\+\_\+t\+::config\+\_\+type cfg, vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ typename fitter\+\_\+t\+::intersection\+\_\+type $>$ nav\+\_\+candidates\+\_\+buffer, \mbox{\hyperlink{structtraccc_1_1container__types_aa6a3c3afb08abf3aad41b6002ef8b48f}{track\+\_\+candidate\+\_\+container\+\_\+types\+::const\+\_\+view}} track\+\_\+candidates\+\_\+view, \mbox{\hyperlink{structtraccc_1_1container__types_a3344afd1f08f09bcec6d7206d380b26c}{track\+\_\+state\+\_\+container\+\_\+types\+::view}} track\+\_\+states\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a9b62b54a150cb456973d25f7a5399ddc}{count\+\_\+doublets}} (std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&config, const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&sp\+\_\+view, const vecmem\+::data\+::vector\+\_\+view$<$ const \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$ \&sp\+\_\+ps\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::view}} doublet\+\_\+view, unsigned int \&n\+Mid\+Bot, unsigned int \&n\+Mid\+Top)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a28d9d10c00bd5852e135b3add3f873ab}{count\+\_\+grid\+\_\+capacities}} (const std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&config, const sp\+\_\+grid\+::axis\+\_\+p0\+\_\+type \&phi\+\_\+axis, const sp\+\_\+grid\+::axis\+\_\+p1\+\_\+type \&z\+\_\+axis, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&spacepoints, vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$ grid\+\_\+capacities)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a697e375f53a1b9c334205c81c71746e4}{count\+\_\+triplets}} (std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&config, const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&sp\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&dc\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&mid\+\_\+bot\+\_\+doublet\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&mid\+\_\+top\+\_\+doublet\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::view}} sp\+M\+\_\+tc, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::view}} mb\+\_\+tc)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_af41f49ac70ec91a9e0065d1586027506}{estimate\+\_\+track\+\_\+params}} (const std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&spacepoints\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{seed\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&seeds\+\_\+view, const \mbox{\hyperlink{namespacetraccc_a3e92464c509aa7ac245244b6083357c2}{vector3}} \&bfield, const std\+::array$<$ \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{traccc\+::scalar}}, \mbox{\hyperlink{namespacetraccc_a65f3496a079e9bdcffaf1d62a5fa4151af60fe71ca99e61d0a0d70fb431aabc04}{traccc\+::e\+\_\+bound\+\_\+size}} $>$ \&stddev, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}} params\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_aaad2fcfe8fb236f1ecb1ac7309370237}{find\+\_\+doublets}} (std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&config, const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&sp\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&dc\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::view}} mb\+\_\+doublets\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::view}} mt\+\_\+doublets\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_aac06f2e5b055c83e3ef9362207f325b3}{find\+\_\+triplets}} (std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&config, const \mbox{\hyperlink{structtraccc_1_1seedfilter__config}{seedfilter\+\_\+config}} \&filter\+\_\+config, const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&sp\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&dc\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&mid\+\_\+top\+\_\+doublet\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&sp\+M\+\_\+tc\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&tc\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+triplet\+\_\+collection\+\_\+types\+::view}} triplet\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_ab5cd1251ac7c7ded70369df125d151e5}{populate\+\_\+grid}} (unsigned int global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&config, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&spacepoints\+\_\+view, \mbox{\hyperlink{namespacetraccc_a5044143e89d8abc4a09e7829850cdfdc}{sp\+\_\+grid\+\_\+view}} grid\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_a0aea434e4a014b6fd621ebd0d7100fbe}{reduce\+\_\+triplet\+\_\+counts}} (const std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&dc\+\_\+view, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::view}} sp\+M\+\_\+tc\+\_\+view, unsigned int \&num\+\_\+triplets)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_ada5aab00f224f7d53c4b717042d099c4}{select\+\_\+seeds}} (const std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfilter__config}{seedfilter\+\_\+config}} \&filter\+\_\+config, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&spacepoints\+\_\+view, const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&internal\+\_\+sp\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&sp\+M\+\_\+tc\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&tc\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+triplet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&triplet\+\_\+view, \mbox{\hyperlink{structtraccc_1_1triplet}{triplet}} $\ast$data, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{seed\+\_\+collection\+\_\+types\+::view}} seed\+\_\+view)
\item 
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void \mbox{\hyperlink{namespacetraccc_1_1device_ab5df4029912b7c1cd4d2186bf9434a1d}{update\+\_\+triplet\+\_\+weights}} (const std\+::size\+\_\+t global\+Index, const \mbox{\hyperlink{structtraccc_1_1seedfilter__config}{seedfilter\+\_\+config}} \&filter\+\_\+config, const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&sp\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&sp\+M\+\_\+tc\+\_\+view, const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&tc\+\_\+view, \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} $\ast$data, \mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+triplet\+\_\+collection\+\_\+types\+::view}} triplet\+\_\+view)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2022 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0

T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2022-\/2023 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0

T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2023 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0

T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2021-\/2023 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0

T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2021-\/2022 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0 

\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{namespacetraccc_1_1device_a14889993c5b104c16822c9ac949b3fa6}\label{namespacetraccc_1_1device_a14889993c5b104c16822c9ac949b3fa6}} 
\index{traccc::device@{traccc::device}!device\_doublet\_collection\_types@{device\_doublet\_collection\_types}}
\index{device\_doublet\_collection\_types@{device\_doublet\_collection\_types}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{device\_doublet\_collection\_types}{device\_doublet\_collection\_types}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_a14889993c5b104c16822c9ac949b3fa6}{traccc\+::device\+::device\+\_\+doublet\+\_\+collection\+\_\+types}} = typedef \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$\mbox{\hyperlink{structtraccc_1_1device_1_1device__doublet}{device\+\_\+doublet}}$>$}



Declare all device doublet collection types. 

\mbox{\Hypertarget{namespacetraccc_1_1device_abb2c4cc2cf52bc55a5d99d90145dccb6}\label{namespacetraccc_1_1device_abb2c4cc2cf52bc55a5d99d90145dccb6}} 
\index{traccc::device@{traccc::device}!device\_triplet\_collection\_types@{device\_triplet\_collection\_types}}
\index{device\_triplet\_collection\_types@{device\_triplet\_collection\_types}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{device\_triplet\_collection\_types}{device\_triplet\_collection\_types}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_abb2c4cc2cf52bc55a5d99d90145dccb6}{traccc\+::device\+::device\+\_\+triplet\+\_\+collection\+\_\+types}} = typedef \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$\mbox{\hyperlink{structtraccc_1_1device_1_1device__triplet}{device\+\_\+triplet}}$>$}



Declare all device triplet collection types. 

\mbox{\Hypertarget{namespacetraccc_1_1device_aad75aaaae6cf52b2ea760947d7832254}\label{namespacetraccc_1_1device_aad75aaaae6cf52b2ea760947d7832254}} 
\index{traccc::device@{traccc::device}!doublet\_counter\_collection\_types@{doublet\_counter\_collection\_types}}
\index{doublet\_counter\_collection\_types@{doublet\_counter\_collection\_types}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{doublet\_counter\_collection\_types}{doublet\_counter\_collection\_types}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_aad75aaaae6cf52b2ea760947d7832254}{traccc\+::device\+::doublet\+\_\+counter\+\_\+collection\+\_\+types}} = typedef \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$\mbox{\hyperlink{structtraccc_1_1device_1_1doublet__counter}{doublet\+\_\+counter}}$>$}



Declare all doublet counter collection types. 

\mbox{\Hypertarget{namespacetraccc_1_1device_a1c67d5b48697c4ad899f28ae69120e33}\label{namespacetraccc_1_1device_a1c67d5b48697c4ad899f28ae69120e33}} 
\index{traccc::device@{traccc::device}!prefix\_sum\_buffer\_t@{prefix\_sum\_buffer\_t}}
\index{prefix\_sum\_buffer\_t@{prefix\_sum\_buffer\_t}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{prefix\_sum\_buffer\_t}{prefix\_sum\_buffer\_t}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_a1c67d5b48697c4ad899f28ae69120e33}{traccc\+::device\+::prefix\+\_\+sum\+\_\+buffer\+\_\+t}} = typedef \mbox{\hyperlink{structtraccc_1_1device_1_1prefix__sum__buffer}{prefix\+\_\+sum\+\_\+buffer}}}

\mbox{\Hypertarget{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}\label{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}} 
\index{traccc::device@{traccc::device}!prefix\_sum\_element\_t@{prefix\_sum\_element\_t}}
\index{prefix\_sum\_element\_t@{prefix\_sum\_element\_t}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{prefix\_sum\_element\_t}{prefix\_sum\_element\_t}}
{\footnotesize\ttfamily typedef thrust\+::pair$<$std\+::size\+\_\+t, std\+::size\+\_\+t$>$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{traccc\+::device\+::prefix\+\_\+sum\+\_\+element\+\_\+t}}}



Type for the individual elements in the prefix sum vector. 

\mbox{\Hypertarget{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}\label{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}} 
\index{traccc::device@{traccc::device}!prefix\_sum\_size\_t@{prefix\_sum\_size\_t}}
\index{prefix\_sum\_size\_t@{prefix\_sum\_size\_t}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{prefix\_sum\_size\_t}{prefix\_sum\_size\_t}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{traccc\+::device\+::prefix\+\_\+sum\+\_\+size\+\_\+t}} = typedef vecmem\+::data\+::vector\+\_\+view$<$int$>$\+::size\+\_\+type}

\mbox{\Hypertarget{namespacetraccc_1_1device_aa455dcfea1cafcf634e98d29957158c1}\label{namespacetraccc_1_1device_aa455dcfea1cafcf634e98d29957158c1}} 
\index{traccc::device@{traccc::device}!prefix\_sum\_t@{prefix\_sum\_t}}
\index{prefix\_sum\_t@{prefix\_sum\_t}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{prefix\_sum\_t}{prefix\_sum\_t}}
{\footnotesize\ttfamily typedef vecmem\+::vector$<$\mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}}$>$ \mbox{\hyperlink{namespacetraccc_1_1device_aa455dcfea1cafcf634e98d29957158c1}{traccc\+::device\+::prefix\+\_\+sum\+\_\+t}}}



Convenience type definition for the return value of the helper function. 

\mbox{\Hypertarget{namespacetraccc_1_1device_a07a09a5bd10fd62d71ec0a77079b9b07}\label{namespacetraccc_1_1device_a07a09a5bd10fd62d71ec0a77079b9b07}} 
\index{traccc::device@{traccc::device}!triplet\_counter\_collection\_types@{triplet\_counter\_collection\_types}}
\index{triplet\_counter\_collection\_types@{triplet\_counter\_collection\_types}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{triplet\_counter\_collection\_types}{triplet\_counter\_collection\_types}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_a07a09a5bd10fd62d71ec0a77079b9b07}{traccc\+::device\+::triplet\+\_\+counter\+\_\+collection\+\_\+types}} = typedef \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$\mbox{\hyperlink{structtraccc_1_1device_1_1triplet__counter}{triplet\+\_\+counter}}$>$}



Declare all triplet counter collection types. 

\mbox{\Hypertarget{namespacetraccc_1_1device_a2f7630c49e9c5a3d23245f542526f4f0}\label{namespacetraccc_1_1device_a2f7630c49e9c5a3d23245f542526f4f0}} 
\index{traccc::device@{traccc::device}!triplet\_counter\_spM\_collection\_types@{triplet\_counter\_spM\_collection\_types}}
\index{triplet\_counter\_spM\_collection\_types@{triplet\_counter\_spM\_collection\_types}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{triplet\_counter\_spM\_collection\_types}{triplet\_counter\_spM\_collection\_types}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacetraccc_1_1device_a2f7630c49e9c5a3d23245f542526f4f0}{traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types}} = typedef \mbox{\hyperlink{structtraccc_1_1collection__types}{collection\+\_\+types}}$<$\mbox{\hyperlink{structtraccc_1_1device_1_1triplet__counter__spM}{triplet\+\_\+counter\+\_\+spM}}$>$}



Declare all triplet counter spM collection types. 



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacetraccc_1_1device_a560c561636e8700675394f3f5a7d7e5d}\label{namespacetraccc_1_1device_a560c561636e8700675394f3f5a7d7e5d}} 
\index{traccc::device@{traccc::device}!aggregate\_cluster@{aggregate\_cluster}}
\index{aggregate\_cluster@{aggregate\_cluster}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{aggregate\_cluster()}{aggregate\_cluster()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::aggregate\+\_\+cluster (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a2c17f74f33da865b1fb58c83e44ecb71}{cell\+\_\+collection\+\_\+types\+::const\+\_\+device}} \&}]{cells,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a2c17f74f33da865b1fb58c83e44ecb71}{cell\+\_\+module\+\_\+collection\+\_\+types\+::const\+\_\+device}} \&}]{modules,  }\item[{const vecmem\+::data\+::vector\+\_\+view$<$ unsigned short $>$}]{f\+\_\+view,  }\item[{const unsigned int}]{start,  }\item[{const unsigned int}]{end,  }\item[{const unsigned short}]{cid,  }\item[{\mbox{\hyperlink{structtraccc_1_1measurement}{measurement}} \&}]{out,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$}]{cell\+\_\+links,  }\item[{const unsigned int}]{link }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function which looks for cells which share the same \char`\"{}parent\char`\"{} index and aggregates them into a cluster.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cells} & collection of cells \\
\hline
\mbox{\texttt{ in}}  & {\em modules} & collection of modules to which the cells are linked to \\
\hline
\mbox{\texttt{ in}}  & {\em f} & array of \char`\"{}parent\char`\"{} indices for all cells in this partition \\
\hline
\mbox{\texttt{ in}}  & {\em start} & partition start point this cell belongs to \\
\hline
\mbox{\texttt{ in}}  & {\em end} & partition end point this cell belongs to \\
\hline
\mbox{\texttt{ in}}  & {\em cid} & current cell id \\
\hline
\mbox{\texttt{ out}}  & {\em out} & cluster to fill \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{22                              \{}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     \textcolor{keyword}{const} vecmem::device\_vector<unsigned short> f(f\_view);}
\DoxyCodeLine{25     vecmem::device\_vector<unsigned int> cell\_links\_device(cell\_links);}
\DoxyCodeLine{26 }
\DoxyCodeLine{27     \textcolor{comment}{/*}}
\DoxyCodeLine{28 \textcolor{comment}{     * Now, we iterate over all other cells to check if they belong}}
\DoxyCodeLine{29 \textcolor{comment}{     * to our cluster. Note that we can start at the current index}}
\DoxyCodeLine{30 \textcolor{comment}{     * because no cell is ever a child of a cluster owned by a cell}}
\DoxyCodeLine{31 \textcolor{comment}{     * with a higher ID.}}
\DoxyCodeLine{32 \textcolor{comment}{     */}}
\DoxyCodeLine{33     \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} totalWeight = 0.;}
\DoxyCodeLine{34     \mbox{\hyperlink{namespacetraccc_a83ee72b67d3c03df43280e5bc169ac7a}{point2}} mean\{0., 0.\}, var\{0., 0.\};}
\DoxyCodeLine{35     \textcolor{keyword}{const} \textcolor{keyword}{auto} module\_link = cells[cid + start].module\_link;}
\DoxyCodeLine{36     \textcolor{keyword}{const} cell\_module this\_module = modules.at(module\_link);}
\DoxyCodeLine{37     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} partition\_size = end -\/ start;}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\_id}} maxChannel1 = std::numeric\_limits<channel\_id>::min();}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} j = cid; j < partition\_size; j++) \{}
\DoxyCodeLine{42 }
\DoxyCodeLine{43         assert(j < f.size());}
\DoxyCodeLine{44 }
\DoxyCodeLine{45         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} pos = j + start;}
\DoxyCodeLine{46         \textcolor{comment}{/*}}
\DoxyCodeLine{47 \textcolor{comment}{         * Terminate the process earlier if we have reached a cell sufficiently}}
\DoxyCodeLine{48 \textcolor{comment}{         * in a different module.}}
\DoxyCodeLine{49 \textcolor{comment}{         */}}
\DoxyCodeLine{50         \textcolor{keywordflow}{if} (cells[pos].module\_link != module\_link) \{}
\DoxyCodeLine{51             \textcolor{keywordflow}{break};}
\DoxyCodeLine{52         \}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54         \textcolor{keyword}{const} cell this\_cell = cells[pos];}
\DoxyCodeLine{55 }
\DoxyCodeLine{56         \textcolor{comment}{/*}}
\DoxyCodeLine{57 \textcolor{comment}{         * If the value of this cell is equal to our, that means it}}
\DoxyCodeLine{58 \textcolor{comment}{         * is part of our cluster. In that case, we take its values}}
\DoxyCodeLine{59 \textcolor{comment}{         * for position and add them to our accumulators.}}
\DoxyCodeLine{60 \textcolor{comment}{         */}}
\DoxyCodeLine{61         \textcolor{keywordflow}{if} (f[j] == cid) \{}
\DoxyCodeLine{62 }
\DoxyCodeLine{63             \textcolor{keywordflow}{if} (this\_cell.channel1 > maxChannel1) \{}
\DoxyCodeLine{64                 maxChannel1 = this\_cell.channel1;}
\DoxyCodeLine{65             \}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67             \textcolor{keyword}{const} \textcolor{keywordtype}{float} weight = \mbox{\hyperlink{namespacetraccc_1_1detail_ab8b9563129faf8333be30d0895d1a6a6}{traccc::detail::signal\_cell\_modelling}}(}
\DoxyCodeLine{68                 this\_cell.activation, this\_module);}
\DoxyCodeLine{69 }
\DoxyCodeLine{70             \textcolor{keywordflow}{if} (weight > this\_module.threshold) \{}
\DoxyCodeLine{71                 totalWeight += this\_cell.activation;}
\DoxyCodeLine{72                 \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_a83ee72b67d3c03df43280e5bc169ac7a}{point2}} cell\_position =}
\DoxyCodeLine{73                     \mbox{\hyperlink{namespacetraccc_1_1detail_a7a2d59fbc63350abdfe5e2af688d24ad}{traccc::detail::position\_from\_cell}}(this\_cell, this\_module);}
\DoxyCodeLine{74                 \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_a83ee72b67d3c03df43280e5bc169ac7a}{point2}} prev = mean;}
\DoxyCodeLine{75                 \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_a83ee72b67d3c03df43280e5bc169ac7a}{point2}} diff = cell\_position -\/ prev;}
\DoxyCodeLine{76 }
\DoxyCodeLine{77                 mean = prev + (weight / totalWeight) * diff;}
\DoxyCodeLine{78                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} i = 0; i < 2; ++i) \{}
\DoxyCodeLine{79                     var[i] = var[i] +}
\DoxyCodeLine{80                              weight * (diff[i]) * (cell\_position[i] -\/ mean[i]);}
\DoxyCodeLine{81                 \}}
\DoxyCodeLine{82             \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84             cell\_links\_device.at(pos) = link;}
\DoxyCodeLine{85         \}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87         \textcolor{comment}{/*}}
\DoxyCodeLine{88 \textcolor{comment}{         * Terminate the process earlier if we have reached a cell sufficiently}}
\DoxyCodeLine{89 \textcolor{comment}{         * far away from the cluster in the dominant axis.}}
\DoxyCodeLine{90 \textcolor{comment}{         */}}
\DoxyCodeLine{91         \textcolor{keywordflow}{if} (this\_cell.channel1 > maxChannel1 + 1) \{}
\DoxyCodeLine{92             \textcolor{keywordflow}{break};}
\DoxyCodeLine{93         \}}
\DoxyCodeLine{94     \}}
\DoxyCodeLine{95     \textcolor{keywordflow}{if} (totalWeight > \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}}\textcolor{keyword}{>}(0.)) \{}
\DoxyCodeLine{96         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} i = 0; i < 2; ++i) \{}
\DoxyCodeLine{97             var[i] /= totalWeight;}
\DoxyCodeLine{98         \}}
\DoxyCodeLine{99         \textcolor{keyword}{const} \textcolor{keyword}{auto} pitch = this\_module.pixel.get\_pitch();}
\DoxyCodeLine{100         var = var + \mbox{\hyperlink{namespacetraccc_a83ee72b67d3c03df43280e5bc169ac7a}{point2}}\{pitch[0] * pitch[0] / \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}}\textcolor{keyword}{>}(12.),}
\DoxyCodeLine{101                            pitch[1] * pitch[1] / \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}}\textcolor{keyword}{>}(12.)\};}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104     \textcolor{comment}{/*}}
\DoxyCodeLine{105 \textcolor{comment}{     * Fill output vector with calculated cluster properties}}
\DoxyCodeLine{106 \textcolor{comment}{     */}}
\DoxyCodeLine{107     out.local = mean;}
\DoxyCodeLine{108     out.variance = var;}
\DoxyCodeLine{109     out.surface\_link = this\_module.surface\_link;}
\DoxyCodeLine{110     out.module\_link = module\_link;}
\DoxyCodeLine{111     \textcolor{comment}{// The following will need to be filled properly "soon".}}
\DoxyCodeLine{112     out.meas\_dim = 2u;}
\DoxyCodeLine{113 \}}

\end{DoxyCode}


References traccc\+::cell\+::activation, traccc\+::cell\+::channel1, traccc\+::pixel\+\_\+data\+::get\+\_\+pitch(), traccc\+::measurement\+::local, traccc\+::measurement\+::meas\+\_\+dim, traccc\+::measurement\+::module\+\_\+link, traccc\+::cell\+\_\+module\+::pixel, traccc\+::detail\+::position\+\_\+from\+\_\+cell(), traccc\+::detail\+::signal\+\_\+cell\+\_\+modelling(), traccc\+::cell\+\_\+module\+::surface\+\_\+link, traccc\+::measurement\+::surface\+\_\+link, traccc\+::cell\+\_\+module\+::threshold, and traccc\+::measurement\+::variance.



Referenced by ccl\+\_\+kernel().

\mbox{\Hypertarget{namespacetraccc_1_1device_acd5f48af899ba8e1b750fd5fd7d46c46}\label{namespacetraccc_1_1device_acd5f48af899ba8e1b750fd5fd7d46c46}} 
\index{traccc::device@{traccc::device}!apply\_interaction@{apply\_interaction}}
\index{apply\_interaction@{apply\_interaction}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{apply\_interaction()}{apply\_interaction()}}
{\footnotesize\ttfamily template$<$typename detector\+\_\+t $>$ \\
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::apply\+\_\+interaction (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{typename detector\+\_\+t\+::view\+\_\+type}]{det\+\_\+data,  }\item[{vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ detray\+::intersection2D$<$ typename detector\+\_\+t\+::surface\+\_\+type, typename detector\+\_\+t\+::transform3 $>$$>$}]{nav\+\_\+candidates\+\_\+buffer,  }\item[{const int}]{n\+\_\+params,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}}}]{params\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function applying the Pre material interaction to tracks spawned by bound track parameters


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em det\+\_\+data} & Detector view object \\
\hline
\mbox{\texttt{ in}}  & {\em nav\+\_\+candidates\+\_\+buffer} & Buffer for navigation candidates \\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+params} & The number of parameters (or tracks) \\
\hline
\mbox{\texttt{ out}}  & {\em params\+\_\+view} & Collection of output bound track\+\_\+parameters \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{23                                                              \{}
\DoxyCodeLine{24 }
\DoxyCodeLine{25     \textcolor{comment}{// Type definitions}}
\DoxyCodeLine{26     \textcolor{keyword}{using} transform3\_type = \textcolor{keyword}{typename} \mbox{\hyperlink{namespacetraccc_a7d1f91ecd225f32ea85349bf0bc8adb8}{detector\_t::transform3}};}
\DoxyCodeLine{27     \textcolor{keyword}{using} intersection\_type =}
\DoxyCodeLine{28         detray::intersection2D<\textcolor{keyword}{typename} detector\_t::surface\_type,}
\DoxyCodeLine{29                                transform3\_type>;}
\DoxyCodeLine{30     \textcolor{keyword}{using} interactor\_type =}
\DoxyCodeLine{31         detray::pointwise\_material\_interactor<transform3\_type>;}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     \textcolor{comment}{// Detector}}
\DoxyCodeLine{34     detector\_t det(det\_data);}
\DoxyCodeLine{35 }
\DoxyCodeLine{36     \textcolor{comment}{// Navigation candidate buffer}}
\DoxyCodeLine{37     vecmem::jagged\_device\_vector<intersection\_type> nav\_candidates(}
\DoxyCodeLine{38         nav\_candidates\_buffer);}
\DoxyCodeLine{39 }
\DoxyCodeLine{40     \textcolor{comment}{// in param}}
\DoxyCodeLine{41     bound\_track\_parameters\_collection\_types::device params(params\_view);}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{keywordflow}{if} (globalIndex >= n\_params) \{}
\DoxyCodeLine{44         \textcolor{keywordflow}{return};}
\DoxyCodeLine{45     \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47     \textcolor{keyword}{auto}\& bound\_param = params.at(globalIndex);}
\DoxyCodeLine{48 }
\DoxyCodeLine{49     \textcolor{comment}{// Get intersection at surface}}
\DoxyCodeLine{50     \textcolor{keyword}{const} detray::surface<detector\_t> sf\{det, bound\_param.surface\_link()\};}
\DoxyCodeLine{51     \textcolor{keyword}{using} cxt\_t = \textcolor{keyword}{typename} detector\_t::geometry\_context;}
\DoxyCodeLine{52     \textcolor{keyword}{const} cxt\_t ctx\{\};}
\DoxyCodeLine{53     \textcolor{keyword}{const} \textcolor{keyword}{auto} free\_vec = sf.bound\_to\_free\_vector(ctx, bound\_param.vector());}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& mask\_store = det.mask\_store();}
\DoxyCodeLine{56     intersection\_type sfi;}
\DoxyCodeLine{57     sfi.sf\_desc = det.surface(bound\_param.surface\_link());}
\DoxyCodeLine{58     sf.template visit\_mask<detray::intersection\_update>(}
\DoxyCodeLine{59         detray::detail::ray<transform3\_type>(free\_vec), sfi,}
\DoxyCodeLine{60         det.transform\_store());}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{comment}{// Apply interactor}}
\DoxyCodeLine{63     \textcolor{keyword}{typename} interactor\_type::state interactor\_state;}
\DoxyCodeLine{64     interactor\_type\{\}.update(}
\DoxyCodeLine{65         bound\_param, interactor\_state,}
\DoxyCodeLine{66         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(detray::navigation::direction::e\_forward), sf,}
\DoxyCodeLine{67         sfi.cos\_incidence\_angle);}
\DoxyCodeLine{68 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetraccc_1_1device_a125de08cb9b6520cb3516fe95c2544a9}\label{namespacetraccc_1_1device_a125de08cb9b6520cb3516fe95c2544a9}} 
\index{traccc::device@{traccc::device}!build\_tracks@{build\_tracks}}
\index{build\_tracks@{build\_tracks}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{build\_tracks()}{build\_tracks()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::build\+\_\+tracks (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{measurements\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{seeds\+\_\+view,  }\item[{vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ const \mbox{\hyperlink{structtraccc_1_1candidate__link}{candidate\+\_\+link}} $>$}]{links\+\_\+view,  }\item[{vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ const unsigned int $>$}]{param\+\_\+to\+\_\+link\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ const typename \mbox{\hyperlink{structtraccc_1_1candidate__link_a43e4355337d1d689215e7a0c69b86636}{candidate\+\_\+link\+::link\+\_\+index\+\_\+type}} $>$}]{tips\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1container__types_a3344afd1f08f09bcec6d7206d380b26c}{track\+\_\+candidate\+\_\+container\+\_\+types\+::view}}}]{track\+\_\+candidates\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function for building full tracks from the link container\+: The full tracks are built using the link container and tip link container. Since every link holds an information of the link from the previous step, we can build a full track by iterating from a tip link backwardly.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em measurements\+\_\+view} & Measurements container view \\
\hline
\mbox{\texttt{ in}}  & {\em seeds\+\_\+view} & Seed container view \\
\hline
\mbox{\texttt{ in}}  & {\em link\+\_\+view} & Link container view \\
\hline
\mbox{\texttt{ in}}  & {\em param\+\_\+to\+\_\+link\+\_\+view} & Container for param index -\/$>$ link index \\
\hline
\mbox{\texttt{ in}}  & {\em tips\+\_\+view} & Tip link container view \\
\hline
\mbox{\texttt{ out}}  & {\em track\+\_\+candidates\+\_\+view} & Track candidate container view \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{20                                                                \{}
\DoxyCodeLine{21 }
\DoxyCodeLine{22     measurement\_collection\_types::const\_device measurements(measurements\_view);}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     bound\_track\_parameters\_collection\_types::const\_device seeds(seeds\_view);}
\DoxyCodeLine{25 }
\DoxyCodeLine{26     vecmem::jagged\_device\_vector<const candidate\_link> links(links\_view);}
\DoxyCodeLine{27 }
\DoxyCodeLine{28     vecmem::jagged\_device\_vector<const unsigned int> param\_to\_link(}
\DoxyCodeLine{29         param\_to\_link\_view);}
\DoxyCodeLine{30 }
\DoxyCodeLine{31     vecmem::device\_vector<const typename candidate\_link::link\_index\_type> tips(}
\DoxyCodeLine{32         tips\_view);}
\DoxyCodeLine{33 }
\DoxyCodeLine{34     track\_candidate\_container\_types::device track\_candidates(}
\DoxyCodeLine{35         track\_candidates\_view);}
\DoxyCodeLine{36 }
\DoxyCodeLine{37     \textcolor{keywordflow}{if} (globalIndex >= tips.size()) \{}
\DoxyCodeLine{38         \textcolor{keywordflow}{return};}
\DoxyCodeLine{39     \}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \textcolor{keyword}{const} \textcolor{keyword}{auto} tip = tips.at(globalIndex);}
\DoxyCodeLine{42     \textcolor{keyword}{auto}\& seed = track\_candidates[globalIndex].header;}
\DoxyCodeLine{43     \textcolor{keyword}{auto} cands\_per\_track = track\_candidates[globalIndex].items;}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     \textcolor{comment}{// Get the link corresponding to tip}}
\DoxyCodeLine{46     \textcolor{keyword}{auto} L = links[tip.first][tip.second];}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{comment}{// Resize the candidates with the exact size}}
\DoxyCodeLine{49     cands\_per\_track.resize(tip.first + 1);}
\DoxyCodeLine{50 }
\DoxyCodeLine{51     \textcolor{comment}{// Reversely iterate to fill the track candidates}}
\DoxyCodeLine{52     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = cands\_per\_track.rbegin(); it != cands\_per\_track.rend();}
\DoxyCodeLine{53          it++) \{}
\DoxyCodeLine{54 }
\DoxyCodeLine{55         \textcolor{keyword}{auto}\& cand = *it;}
\DoxyCodeLine{56         cand = \{measurements.at(L.meas\_idx)\};}
\DoxyCodeLine{57 }
\DoxyCodeLine{58         \textcolor{comment}{// Break the loop if the iterator is at the first candidate and fill the}}
\DoxyCodeLine{59         \textcolor{comment}{// seed}}
\DoxyCodeLine{60         \textcolor{keywordflow}{if} (it == cands\_per\_track.rend() -\/ 1) \{}
\DoxyCodeLine{61             seed = seeds.at(L.previous.second);}
\DoxyCodeLine{62             \textcolor{keywordflow}{break};}
\DoxyCodeLine{63         \}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65         \textcolor{keyword}{const} \textcolor{keyword}{auto} l\_pos = param\_to\_link[L.previous.first][L.previous.second];}
\DoxyCodeLine{66 }
\DoxyCodeLine{67         L = links[L.previous.first][l\_pos];}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69 \}}

\end{DoxyCode}


References traccc\+::device\+\_\+container$<$ header\+\_\+t, item\+\_\+t $>$\+::at().

\mbox{\Hypertarget{namespacetraccc_1_1device_a581cd4e1e686b1e742185eac2da41369}\label{namespacetraccc_1_1device_a581cd4e1e686b1e742185eac2da41369}} 
\index{traccc::device@{traccc::device}!ccl\_kernel@{ccl\_kernel}}
\index{ccl\_kernel@{ccl\_kernel}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{ccl\_kernel()}{ccl\_kernel()}}
{\footnotesize\ttfamily template$<$typename barrier\+\_\+t $>$ \\
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::ccl\+\_\+kernel (\begin{DoxyParamCaption}\item[{const index\+\_\+t}]{thread\+Id,  }\item[{const index\+\_\+t}]{blck\+Dim,  }\item[{const unsigned int}]{block\+Id,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{cell\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{cells\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{cell\+\_\+module\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{modules\+\_\+view,  }\item[{const index\+\_\+t}]{max\+\_\+cells\+\_\+per\+\_\+partition,  }\item[{const index\+\_\+t}]{target\+\_\+cells\+\_\+per\+\_\+partition,  }\item[{unsigned int \&}]{partition\+\_\+start,  }\item[{unsigned int \&}]{partition\+\_\+end,  }\item[{unsigned int \&}]{outi,  }\item[{index\+\_\+t $\ast$}]{f,  }\item[{index\+\_\+t $\ast$}]{gf,  }\item[{barrier\+\_\+t \&}]{barrier,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{measurement\+\_\+collection\+\_\+types\+::view}}}]{measurements\+\_\+view,  }\item[{unsigned int \&}]{measurement\+\_\+count,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$}]{cell\+\_\+links }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function which reads raw detector cells and turns them into measurements.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em thread\+Id} & current thread index \\
\hline
\mbox{\texttt{ in}}  & {\em blck\+Dim} & current thread block size \\
\hline
\mbox{\texttt{ in}}  & {\em blck\+Id} & current thread block index \\
\hline
\mbox{\texttt{ in}}  & {\em cells\+\_\+view} & collection of cells \\
\hline
\mbox{\texttt{ in}}  & {\em modules\+\_\+view} & collection of modules to which the cells are linked \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+cells\+\_\+per\+\_\+partition} & maximum number of cells per thread block \\
\hline
\mbox{\texttt{ in}}  & {\em target\+\_\+cells\+\_\+per\+\_\+partition} & average number of cells per thread block \\
\hline
 & {\em partition\+\_\+start} & partition start point for this thread block \\
\hline
 & {\em partition\+\_\+end} & partition end point for this thread block \\
\hline
 & {\em outi} & number of measurements for this partition \\
\hline
 & {\em f} & array of \char`\"{}parent\char`\"{} indices for all cells in this partition \\
\hline
 & {\em gf} & array of \char`\"{}grandparent\char`\"{} indices for all cells in this partition \\
\hline
 & {\em barrier} & A generic object for block-\/wide synchronisation \\
\hline
\mbox{\texttt{ out}}  & {\em measurements\+\_\+view} & collection of measurements \\
\hline
\mbox{\texttt{ out}}  & {\em measurement\+\_\+count} & number of measurements \\
\hline
\mbox{\texttt{ out}}  & {\em cell\+\_\+links} & collection of links to measurements each cell is put into \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{133                                                     \{}
\DoxyCodeLine{134 }
\DoxyCodeLine{135     \textcolor{comment}{// Get device copy of input parameters}}
\DoxyCodeLine{136     \textcolor{keyword}{const} cell\_collection\_types::const\_device cells\_device(cells\_view);}
\DoxyCodeLine{137     \textcolor{keyword}{const} cell\_module\_collection\_types::const\_device modules\_device(}
\DoxyCodeLine{138         modules\_view);}
\DoxyCodeLine{139     measurement\_collection\_types::device measurements\_device(measurements\_view);}
\DoxyCodeLine{140 }
\DoxyCodeLine{141     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num\_cells = cells\_device.size();}
\DoxyCodeLine{142 }
\DoxyCodeLine{143     \textcolor{comment}{/*}}
\DoxyCodeLine{144 \textcolor{comment}{     * First, we determine the exact range of cells that is to be examined}}
\DoxyCodeLine{145 \textcolor{comment}{     * by this block of threads. We start from an initial range determined}}
\DoxyCodeLine{146 \textcolor{comment}{     * by the block index multiplied by the target number of cells per}}
\DoxyCodeLine{147 \textcolor{comment}{     * block. We then shift both the start and the end of the block forward}}
\DoxyCodeLine{148 \textcolor{comment}{     * (to a later point in the array); start and end may be moved different}}
\DoxyCodeLine{149 \textcolor{comment}{     * amounts.}}
\DoxyCodeLine{150 \textcolor{comment}{     */}}
\DoxyCodeLine{151     \textcolor{keywordflow}{if} (threadId == 0) \{}
\DoxyCodeLine{152         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} start = blockId * target\_cells\_per\_partition;}
\DoxyCodeLine{153         assert(start < num\_cells);}
\DoxyCodeLine{154         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} end =}
\DoxyCodeLine{155             std::min(num\_cells, start + target\_cells\_per\_partition);}
\DoxyCodeLine{156         outi = 0;}
\DoxyCodeLine{157 }
\DoxyCodeLine{158         \textcolor{comment}{/*}}
\DoxyCodeLine{159 \textcolor{comment}{         * Next, shift the starting point to a position further in the}}
\DoxyCodeLine{160 \textcolor{comment}{         * array; the purpose of this is to ensure that we are not operating}}
\DoxyCodeLine{161 \textcolor{comment}{         * on any cells that have been claimed by the previous block (if}}
\DoxyCodeLine{162 \textcolor{comment}{         * any).}}
\DoxyCodeLine{163 \textcolor{comment}{         */}}
\DoxyCodeLine{164         \textcolor{keywordflow}{while} (start != 0 \&\&}
\DoxyCodeLine{165                cells\_device[start -\/ 1].module\_link ==}
\DoxyCodeLine{166                    cells\_device[start].module\_link \&\&}
\DoxyCodeLine{167                cells\_device[start].channel1 <=}
\DoxyCodeLine{168                    cells\_device[start -\/ 1].channel1 + 1) \{}
\DoxyCodeLine{169             ++start;}
\DoxyCodeLine{170         \}}
\DoxyCodeLine{171 }
\DoxyCodeLine{172         \textcolor{comment}{/*}}
\DoxyCodeLine{173 \textcolor{comment}{         * Then, claim as many cells as we need past the naive end of the}}
\DoxyCodeLine{174 \textcolor{comment}{         * current block to ensure that we do not end our partition on a}}
\DoxyCodeLine{175 \textcolor{comment}{         * cell that is not a possible boundary!}}
\DoxyCodeLine{176 \textcolor{comment}{         */}}
\DoxyCodeLine{177         \textcolor{keywordflow}{while} (end < num\_cells \&\&}
\DoxyCodeLine{178                cells\_device[end -\/ 1].module\_link ==}
\DoxyCodeLine{179                    cells\_device[end].module\_link \&\&}
\DoxyCodeLine{180                cells\_device[end].channel1 <=}
\DoxyCodeLine{181                    cells\_device[end -\/ 1].channel1 + 1) \{}
\DoxyCodeLine{182             ++end;}
\DoxyCodeLine{183         \}}
\DoxyCodeLine{184         partition\_start = start;}
\DoxyCodeLine{185         partition\_end = end;}
\DoxyCodeLine{186     \}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188     barrier.blockBarrier();}
\DoxyCodeLine{189 }
\DoxyCodeLine{190     \textcolor{comment}{// Vector of indices of the adjacent cells}}
\DoxyCodeLine{191     index\_t adjv[MAX\_CELLS\_PER\_THREAD][8];}
\DoxyCodeLine{192     \textcolor{comment}{/*}}
\DoxyCodeLine{193 \textcolor{comment}{     * The number of adjacent cells for each cell must start at zero, to}}
\DoxyCodeLine{194 \textcolor{comment}{     * avoid uninitialized memory. adjv does not need to be zeroed, as}}
\DoxyCodeLine{195 \textcolor{comment}{     * we will only access those values if adjc indicates that the value}}
\DoxyCodeLine{196 \textcolor{comment}{     * is set.}}
\DoxyCodeLine{197 \textcolor{comment}{     */}}
\DoxyCodeLine{198     \textcolor{comment}{// Number of adjacent cells}}
\DoxyCodeLine{199     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} adjc[MAX\_CELLS\_PER\_THREAD];}
\DoxyCodeLine{200 }
\DoxyCodeLine{201     \textcolor{comment}{// It seems that sycl runs into undefined behaviour when calling}}
\DoxyCodeLine{202     \textcolor{comment}{// group synchronisation functions when some threads have already run}}
\DoxyCodeLine{203     \textcolor{comment}{// into a return. As such, we cannot use returns in this kernel.}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205     \textcolor{comment}{// Get partition for this thread group}}
\DoxyCodeLine{206     \textcolor{keyword}{const} index\_t size = partition\_end -\/ partition\_start;}
\DoxyCodeLine{207     assert(size <= max\_cells\_per\_partition);}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{preprocessor}{\#pragma unroll}}
\DoxyCodeLine{210     \textcolor{keywordflow}{for} (index\_t tst = 0; tst < MAX\_CELLS\_PER\_THREAD; ++tst) \{}
\DoxyCodeLine{211         adjc[tst] = 0;}
\DoxyCodeLine{212     \}}
\DoxyCodeLine{213 }
\DoxyCodeLine{214     \textcolor{keywordflow}{for} (index\_t tst = 0, cid; (cid = tst * blckDim + threadId) < size; ++tst) \{}
\DoxyCodeLine{215         \textcolor{comment}{/*}}
\DoxyCodeLine{216 \textcolor{comment}{         * Look for adjacent cells to the current one.}}
\DoxyCodeLine{217 \textcolor{comment}{         */}}
\DoxyCodeLine{218         \mbox{\hyperlink{namespacetraccc_1_1device_ab8368c09597104f9b3fecf98b4a1111d}{device::reduce\_problem\_cell}}(cells\_device, cid, partition\_start,}
\DoxyCodeLine{219                                     partition\_end, adjc[tst], adjv[tst]);}
\DoxyCodeLine{220     \}}
\DoxyCodeLine{221 }
\DoxyCodeLine{222 \textcolor{preprocessor}{\#pragma unroll}}
\DoxyCodeLine{223     \textcolor{keywordflow}{for} (index\_t tst = 0; tst < MAX\_CELLS\_PER\_THREAD; ++tst) \{}
\DoxyCodeLine{224         \textcolor{keyword}{const} index\_t cid = tst * blckDim + threadId;}
\DoxyCodeLine{225         \textcolor{comment}{/*}}
\DoxyCodeLine{226 \textcolor{comment}{         * At the start, the values of f and gf should be equal to the}}
\DoxyCodeLine{227 \textcolor{comment}{         * ID of the cell.}}
\DoxyCodeLine{228 \textcolor{comment}{         */}}
\DoxyCodeLine{229         f[cid] = cid;}
\DoxyCodeLine{230         gf[cid] = cid;}
\DoxyCodeLine{231     \}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233     \textcolor{comment}{/*}}
\DoxyCodeLine{234 \textcolor{comment}{     * Now that the data has initialized, we synchronize again before we}}
\DoxyCodeLine{235 \textcolor{comment}{     * move onto the actual processing part.}}
\DoxyCodeLine{236 \textcolor{comment}{     */}}
\DoxyCodeLine{237     barrier.blockBarrier();}
\DoxyCodeLine{238 }
\DoxyCodeLine{239     \textcolor{comment}{/*}}
\DoxyCodeLine{240 \textcolor{comment}{     * Run FastSV algorithm, which will update the father index to that of}}
\DoxyCodeLine{241 \textcolor{comment}{     * the cell belonging to the same cluster with the lowest index.}}
\DoxyCodeLine{242 \textcolor{comment}{     */}}
\DoxyCodeLine{243     \mbox{\hyperlink{namespacetraccc_1_1device_a2fc626e715c5d48a0d3261d70d479dd5}{fast\_sv\_1}}(\&f[0], \&gf[0], adjc, adjv, threadId, blckDim, barrier);}
\DoxyCodeLine{244 }
\DoxyCodeLine{245     barrier.blockBarrier();}
\DoxyCodeLine{246 }
\DoxyCodeLine{247     \textcolor{comment}{/*}}
\DoxyCodeLine{248 \textcolor{comment}{     * Count the number of clusters by checking how many cells have}}
\DoxyCodeLine{249 \textcolor{comment}{     * themself assigned as a parent.}}
\DoxyCodeLine{250 \textcolor{comment}{     */}}
\DoxyCodeLine{251     \textcolor{keywordflow}{for} (index\_t tst = 0, cid; (cid = tst * blckDim + threadId) < size; ++tst) \{}
\DoxyCodeLine{252 }
\DoxyCodeLine{253         \textcolor{keywordflow}{if} (f[cid] == cid) \{}
\DoxyCodeLine{254             \textcolor{comment}{// Increment the summary values in the header object.}}
\DoxyCodeLine{255             vecmem::device\_atomic\_ref<\textcolor{keywordtype}{unsigned} int,}
\DoxyCodeLine{256                                       vecmem::device\_address\_space::local>}
\DoxyCodeLine{257                 atom(outi);}
\DoxyCodeLine{258             atom.fetch\_add(1);}
\DoxyCodeLine{259         \}}
\DoxyCodeLine{260     \}}
\DoxyCodeLine{261 }
\DoxyCodeLine{262     barrier.blockBarrier();}
\DoxyCodeLine{263 }
\DoxyCodeLine{264     \textcolor{comment}{/*}}
\DoxyCodeLine{265 \textcolor{comment}{     * Add the number of clusters of each thread block to the total}}
\DoxyCodeLine{266 \textcolor{comment}{     * number of clusters. At the same time, a cluster id is retrieved}}
\DoxyCodeLine{267 \textcolor{comment}{     * for the next data processing step.}}
\DoxyCodeLine{268 \textcolor{comment}{     * Note that this might be not the same cluster as has been treated}}
\DoxyCodeLine{269 \textcolor{comment}{     * previously. However, since each thread block spawns a the maximum}}
\DoxyCodeLine{270 \textcolor{comment}{     * amount of threads per block, this has no sever implications.}}
\DoxyCodeLine{271 \textcolor{comment}{     */}}
\DoxyCodeLine{272     \textcolor{keywordflow}{if} (threadId == 0) \{}
\DoxyCodeLine{273         vecmem::device\_atomic\_ref<\textcolor{keywordtype}{unsigned} int,}
\DoxyCodeLine{274                                   vecmem::device\_address\_space::global>}
\DoxyCodeLine{275             atom(measurement\_count);}
\DoxyCodeLine{276         outi = atom.fetch\_add(outi);}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278 }
\DoxyCodeLine{279     barrier.blockBarrier();}
\DoxyCodeLine{280 }
\DoxyCodeLine{281     \textcolor{comment}{/*}}
\DoxyCodeLine{282 \textcolor{comment}{     * Get the position to fill the measurements found in this thread group.}}
\DoxyCodeLine{283 \textcolor{comment}{     */}}
\DoxyCodeLine{284     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} groupPos = outi;}
\DoxyCodeLine{285 }
\DoxyCodeLine{286     barrier.blockBarrier();}
\DoxyCodeLine{287 }
\DoxyCodeLine{288     \textcolor{keywordflow}{if} (threadId == 0) \{}
\DoxyCodeLine{289         outi = 0;}
\DoxyCodeLine{290     \}}
\DoxyCodeLine{291 }
\DoxyCodeLine{292     barrier.blockBarrier();}
\DoxyCodeLine{293 }
\DoxyCodeLine{294     \textcolor{keyword}{const} vecmem::data::vector\_view<unsigned short> f\_view(}
\DoxyCodeLine{295         max\_cells\_per\_partition, \&f[0]);}
\DoxyCodeLine{296 }
\DoxyCodeLine{297     \textcolor{keywordflow}{for} (index\_t tst = 0, cid; (cid = tst * blckDim + threadId) < size; ++tst) \{}
\DoxyCodeLine{298         \textcolor{keywordflow}{if} (f[cid] == cid) \{}
\DoxyCodeLine{299             \textcolor{comment}{/*}}
\DoxyCodeLine{300 \textcolor{comment}{             * If we are a cluster owner, atomically claim a position in the}}
\DoxyCodeLine{301 \textcolor{comment}{             * output array which we can write to.}}
\DoxyCodeLine{302 \textcolor{comment}{             */}}
\DoxyCodeLine{303             vecmem::device\_atomic\_ref<\textcolor{keywordtype}{unsigned} int,}
\DoxyCodeLine{304                                       vecmem::device\_address\_space::local>}
\DoxyCodeLine{305                 atom(outi);}
\DoxyCodeLine{306             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = atom.fetch\_add(1);}
\DoxyCodeLine{307 }
\DoxyCodeLine{308             \mbox{\hyperlink{namespacetraccc_1_1device_a560c561636e8700675394f3f5a7d7e5d}{device::aggregate\_cluster}}(cells\_device, modules\_device, f\_view,}
\DoxyCodeLine{309                                       partition\_start, partition\_end, cid,}
\DoxyCodeLine{310                                       measurements\_device[groupPos + \textcolor{keywordtype}{id}],}
\DoxyCodeLine{311                                       cell\_links, groupPos + \textcolor{keywordtype}{id});}
\DoxyCodeLine{312         \}}
\DoxyCodeLine{313     \}}
\DoxyCodeLine{314 \}}

\end{DoxyCode}


References aggregate\+\_\+cluster(), fast\+\_\+sv\+\_\+1(), and reduce\+\_\+problem\+\_\+cell().

\mbox{\Hypertarget{namespacetraccc_1_1device_a9b62b54a150cb456973d25f7a5399ddc}\label{namespacetraccc_1_1device_a9b62b54a150cb456973d25f7a5399ddc}} 
\index{traccc::device@{traccc::device}!count\_doublets@{count\_doublets}}
\index{count\_doublets@{count\_doublets}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{count\_doublets()}{count\_doublets()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::count\+\_\+doublets (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&}]{config,  }\item[{const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&}]{sp\+\_\+view,  }\item[{const vecmem\+::data\+::vector\+\_\+view$<$ const \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$ \&}]{sp\+\_\+ps\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::view}}}]{doublet\+\_\+view,  }\item[{unsigned int \&}]{n\+Mid\+Bot,  }\item[{unsigned int \&}]{n\+Mid\+Top }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for calculating the number of spacepoint doublets

The count is necessary for allocating the appropriate amount of memory for storing the information of the candidates in a next step.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em config} & Seedfinder configuration \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+\_\+view} & The spacepoint grid to count doublets on \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+\_\+ps\+\_\+view} & Prefix sum for iterating over the spacepoint grid \\
\hline
\mbox{\texttt{ out}}  & {\em doublet\+\_\+view} & Collection storing the number of doublets for each spacepoint \\
\hline
\mbox{\texttt{ out}}  & {\em n\+Mid\+Bot} & Total number of middle-\/bottom doublets \\
\hline
\mbox{\texttt{ out}}  & {\em n\+Mid\+Top} & Total number of middle-\/top doublets \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{27                            \{}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{30     vecmem::device\_vector<const prefix\_sum\_element\_t> sp\_prefix\_sum(sp\_ps\_view);}
\DoxyCodeLine{31     \textcolor{keywordflow}{if} (globalIndex >= sp\_prefix\_sum.size()) \{}
\DoxyCodeLine{32         \textcolor{keywordflow}{return};}
\DoxyCodeLine{33     \}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// Get the middle spacepoint that we need to be looking at.}}
\DoxyCodeLine{36     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\_sum\_element\_t}} middle\_sp\_idx = sp\_prefix\_sum[globalIndex];}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \textcolor{comment}{// Set up the device containers.}}
\DoxyCodeLine{39     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_afdad33573f6399c7e2671b6968dfc29c}{const\_sp\_grid\_device}} \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}(sp\_view);}
\DoxyCodeLine{40     doublet\_counter\_collection\_types::device doublet\_counter(doublet\_view);}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{comment}{// Get the spacepoint that we're evaluating in this thread, and treat that}}
\DoxyCodeLine{43     \textcolor{comment}{// as the "middle" spacepoint.}}
\DoxyCodeLine{44     \textcolor{keyword}{const} internal\_spacepoint<spacepoint> middle\_sp =}
\DoxyCodeLine{45         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(middle\_sp\_idx.first).at(middle\_sp\_idx.second);}
\DoxyCodeLine{46 }
\DoxyCodeLine{47     \textcolor{comment}{// The the IDs of the neighbouring bins along the phi and Z axes of the}}
\DoxyCodeLine{48     \textcolor{comment}{// grid.}}
\DoxyCodeLine{49     \textcolor{keyword}{const} detray::dindex\_range phi\_bins =}
\DoxyCodeLine{50         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().range(middle\_sp.phi(), config.neighbor\_scope);}
\DoxyCodeLine{51     \textcolor{keyword}{const} detray::dindex\_range z\_bins =}
\DoxyCodeLine{52         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p1().range(middle\_sp.z(), config.neighbor\_scope);}
\DoxyCodeLine{53     assert(z\_bins[0] <= z\_bins[1]);}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{comment}{// The number of middle-\/bottom candidates found for this thread's middle}}
\DoxyCodeLine{56     \textcolor{comment}{// spacepoint.}}
\DoxyCodeLine{57     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_mb\_cand = 0;}
\DoxyCodeLine{58     \textcolor{comment}{// The number of middle-\/top candidates found for this thread's middle}}
\DoxyCodeLine{59     \textcolor{comment}{// spacepoint.}}
\DoxyCodeLine{60     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_mt\_cand = 0;}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{comment}{// Iterate over all of the neighboring phi bins, including the same bin that}}
\DoxyCodeLine{63     \textcolor{comment}{// the middle spacepoint is in. The loop over the phi bins needs to take}}
\DoxyCodeLine{64     \textcolor{comment}{// into account that we may iterate over the "wrap around point" of the}}
\DoxyCodeLine{65     \textcolor{comment}{// axis.}}
\DoxyCodeLine{66     \textcolor{keywordflow}{for} (detray::dindex phi\_bin\_iterator = phi\_bins[0];}
\DoxyCodeLine{67          phi\_bin\_iterator <=}
\DoxyCodeLine{68          (phi\_bins[1] +}
\DoxyCodeLine{69           (phi\_bins[0] > phi\_bins[1] ? \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().n\_bins : 0));}
\DoxyCodeLine{70          ++phi\_bin\_iterator) \{}
\DoxyCodeLine{71 }
\DoxyCodeLine{72         \textcolor{comment}{// Set up the phi bin index that we are actually meant to use inside of}}
\DoxyCodeLine{73         \textcolor{comment}{// the loop. We could also use a modulo operation here, but that would}}
\DoxyCodeLine{74         \textcolor{comment}{// be slightly more expensive in this specific case.}}
\DoxyCodeLine{75         \textcolor{keyword}{const} detray::dindex phi\_bin =}
\DoxyCodeLine{76             (phi\_bin\_iterator >= \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().n\_bins}
\DoxyCodeLine{77                  ? phi\_bin\_iterator -\/ \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().n\_bins}
\DoxyCodeLine{78                  : phi\_bin\_iterator);}
\DoxyCodeLine{79 }
\DoxyCodeLine{80         \textcolor{comment}{// Iterate over all of the neighboring Z bins, including the same bin}}
\DoxyCodeLine{81         \textcolor{comment}{// that the middle spacepoint is in. This is a much easier iteration, as}}
\DoxyCodeLine{82         \textcolor{comment}{// the Z axis does not "wrap around".}}
\DoxyCodeLine{83         \textcolor{keywordflow}{for} (detray::dindex z\_bin = z\_bins[0]; z\_bin <= z\_bins[1]; ++z\_bin) \{}
\DoxyCodeLine{84 }
\DoxyCodeLine{85             \textcolor{comment}{// Ask the grid for all of the spacepoints in this specific bin.}}
\DoxyCodeLine{86             \textcolor{keyword}{typename} \mbox{\hyperlink{namespacetraccc_1_1details_1_1functor_a357582a9a6874cb71ff052105af32ab2}{const\_sp\_grid\_device::serialized\_storage::const\_reference}}}
\DoxyCodeLine{87                 spacepoints = \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(phi\_bin, z\_bin);}
\DoxyCodeLine{88 }
\DoxyCodeLine{89             \textcolor{comment}{// Loop over all of those spacepoints.}}
\DoxyCodeLine{90             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} internal\_spacepoint<spacepoint> other\_sp : spacepoints) \{}
\DoxyCodeLine{91 }
\DoxyCodeLine{92                 \textcolor{comment}{// Check if this spacepoint is a compatible "bottom" spacepoint}}
\DoxyCodeLine{93                 \textcolor{comment}{// to the thread's "middle" spacepoint.}}
\DoxyCodeLine{94                 \textcolor{keywordflow}{if} (doublet\_finding\_helper::isCompatible<}
\DoxyCodeLine{95                         details::spacepoint\_type::bottom>(middle\_sp, other\_sp,}
\DoxyCodeLine{96                                                           config)) \{}
\DoxyCodeLine{97                     ++n\_mb\_cand;}
\DoxyCodeLine{98                 \}}
\DoxyCodeLine{99                 \textcolor{comment}{// Check if this spacepoint is a compatible "top" spacepoint to}}
\DoxyCodeLine{100                 \textcolor{comment}{// the thread's "middle" spacepoint.}}
\DoxyCodeLine{101                 \textcolor{keywordflow}{if} (doublet\_finding\_helper::isCompatible<}
\DoxyCodeLine{102                         details::spacepoint\_type::top>(middle\_sp, other\_sp,}
\DoxyCodeLine{103                                                        config)) \{}
\DoxyCodeLine{104                     ++n\_mt\_cand;}
\DoxyCodeLine{105                 \}}
\DoxyCodeLine{106             \}}
\DoxyCodeLine{107         \}}
\DoxyCodeLine{108     \}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110     \textcolor{comment}{// Add the counts if compatible bottom *AND* top candidates were found for}}
\DoxyCodeLine{111     \textcolor{comment}{// the middle spacepoint in question.}}
\DoxyCodeLine{112     \textcolor{keywordflow}{if} ((n\_mb\_cand > 0) \&\& (n\_mt\_cand > 0)) \{}
\DoxyCodeLine{113 }
\DoxyCodeLine{114         \textcolor{comment}{// Increment the summary values in the header object.}}
\DoxyCodeLine{115         vecmem::device\_atomic\_ref<unsigned int> numMidBot(nMidBot);}
\DoxyCodeLine{116         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} posBot = numMidBot.fetch\_add(n\_mb\_cand);}
\DoxyCodeLine{117         vecmem::device\_atomic\_ref<unsigned int> numMidTop(nMidTop);}
\DoxyCodeLine{118         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} posTop = numMidTop.fetch\_add(n\_mt\_cand);}
\DoxyCodeLine{119 }
\DoxyCodeLine{120         \textcolor{comment}{// Add the number of candidates for the "current bin".}}
\DoxyCodeLine{121         doublet\_counter.push\_back(}
\DoxyCodeLine{122             \{\{\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(middle\_sp\_idx.first),}
\DoxyCodeLine{123               \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(middle\_sp\_idx.second)\},}
\DoxyCodeLine{124              n\_mb\_cand,}
\DoxyCodeLine{125              n\_mt\_cand,}
\DoxyCodeLine{126              posBot,}
\DoxyCodeLine{127              posTop\});}
\DoxyCodeLine{128     \}}
\DoxyCodeLine{129 \}}

\end{DoxyCode}


References traccc\+::details\+::bottom, traccc\+::doublet\+\_\+finding\+\_\+helper\+::is\+Compatible(), traccc\+::seedfinder\+\_\+config\+::neighbor\+\_\+scope, traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::phi(), traccc\+::details\+::top, and traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::z().

\mbox{\Hypertarget{namespacetraccc_1_1device_a28d9d10c00bd5852e135b3add3f873ab}\label{namespacetraccc_1_1device_a28d9d10c00bd5852e135b3add3f873ab}} 
\index{traccc::device@{traccc::device}!count\_grid\_capacities@{count\_grid\_capacities}}
\index{count\_grid\_capacities@{count\_grid\_capacities}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{count\_grid\_capacities()}{count\_grid\_capacities()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::count\+\_\+grid\+\_\+capacities (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&}]{config,  }\item[{const sp\+\_\+grid\+::axis\+\_\+p0\+\_\+type \&}]{phi\+\_\+axis,  }\item[{const sp\+\_\+grid\+::axis\+\_\+p1\+\_\+type \&}]{z\+\_\+axis,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{spacepoints,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$}]{grid\+\_\+capacities }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for calculating the capacity for the spacepoint grid

Before filling the spacepoint grid with the spacepoints that belong to each grid bin, we need to calculate how big each of those bins are going to be.

This function needs to be called separately for every spacepoint of the event.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em config} & Seedfinder configuration \\
\hline
\mbox{\texttt{ in}}  & {\em phi\+\_\+axis} & The circular \&Phi axis describing the geometry \\
\hline
\mbox{\texttt{ in}}  & {\em z\+\_\+axis} & The linear Z axis describing the geometry \\
\hline
\mbox{\texttt{ in}}  & {\em spacepoints} & All the spacepoints of the event \\
\hline
\mbox{\texttt{ out}}  & {\em grid\+\_\+capacities} & Capacity required for each spacepoint grid bin \\
\hline
\end{DoxyParams}
Check out if the spacepoint can be used for seeding.

Check out if the spacepoint can be used for seeding.
\begin{DoxyCode}{0}
\DoxyCodeLine{23                                                               \{}
\DoxyCodeLine{24 }
\DoxyCodeLine{25     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{26     \textcolor{keyword}{const} spacepoint\_collection\_types::const\_device spacepoints(}
\DoxyCodeLine{27         spacepoints\_view);}
\DoxyCodeLine{28     \textcolor{keywordflow}{if} (globalIndex >= spacepoints.size()) \{}
\DoxyCodeLine{29         \textcolor{keywordflow}{return};}
\DoxyCodeLine{30     \}}
\DoxyCodeLine{31     \textcolor{keyword}{const} spacepoint sp = spacepoints.at(globalIndex);}
\DoxyCodeLine{32 }
\DoxyCodeLine{34     \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetraccc_a4e12ff4b9f7297ad771d4fe8ecc17304}{is\_valid\_sp}}(config, sp) != detray::detail::invalid\_value<size\_t>()) \{}
\DoxyCodeLine{35 }
\DoxyCodeLine{36         \textcolor{comment}{// Find the grid bin that the spacepoint belongs to.}}
\DoxyCodeLine{37         \textcolor{keyword}{const} internal\_spacepoint<spacepoint> isp(sp, globalIndex,}
\DoxyCodeLine{38                                                   config.beamPos);}
\DoxyCodeLine{39         \textcolor{keyword}{const} std::size\_t bin\_index =}
\DoxyCodeLine{40             phi\_axis.bin(isp.phi()) + phi\_axis.bins() * z\_axis.bin(isp.z());}
\DoxyCodeLine{41 }
\DoxyCodeLine{42         \textcolor{comment}{// Increase the capacity of the grid bin.}}
\DoxyCodeLine{43         vecmem::device\_vector<unsigned int> grid\_capacities(}
\DoxyCodeLine{44             grid\_capacities\_view);}
\DoxyCodeLine{45         vecmem::device\_atomic\_ref<unsigned int> bin\_content(}
\DoxyCodeLine{46             grid\_capacities[bin\_index]);}
\DoxyCodeLine{47         bin\_content.fetch\_add(1);}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49 \}}

\end{DoxyCode}


References traccc\+::seedfinder\+\_\+config\+::beam\+Pos, traccc\+::is\+\_\+valid\+\_\+sp(), traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::phi(), and traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::z().



Referenced by traccc\+::alpaka\+::\+Count\+Grid\+Capacity\+Kernel\+::operator()(), and traccc\+::kokkos\+::spacepoint\+\_\+binning\+::operator()().

\mbox{\Hypertarget{namespacetraccc_1_1device_a2875a7c6e478ac6bc7a5cc80dc49dcd4}\label{namespacetraccc_1_1device_a2875a7c6e478ac6bc7a5cc80dc49dcd4}} 
\index{traccc::device@{traccc::device}!count\_measurements@{count\_measurements}}
\index{count\_measurements@{count\_measurements}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{count\_measurements()}{count\_measurements()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::count\+\_\+measurements (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{params\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ const detray\+::geometry\+::barcode $>$}]{barcodes\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ const unsigned int $>$}]{upper\+\_\+bounds\+\_\+view,  }\item[{const unsigned int}]{n\+\_\+in\+\_\+params,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$}]{n\+\_\+measurements\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$}]{ref\+\_\+meas\+\_\+idx\+\_\+view,  }\item[{unsigned int \&}]{n\+\_\+measurements\+\_\+sum }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function evalulating the number of measurements to be iterated per thread and the total number of measurements


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em params\+\_\+view} & Input parameters view object \\
\hline
\mbox{\texttt{ in}}  & {\em barcodes\+\_\+view} & Barcodes view object \\
\hline
\mbox{\texttt{ in}}  & {\em upper\+\_\+bounds} & Upper bounds of measurements w.\+r.\+t geometry ID \\
\hline
\mbox{\texttt{ out}}  & {\em n\+\_\+measurements\+\_\+view} & The number of measurements per parameter \\
\hline
\mbox{\texttt{ out}}  & {\em ref\+\_\+meas\+\_\+idx} & The first index of measurements per parameter \\
\hline
\mbox{\texttt{ out}}  & {\em n\+\_\+measurements\+\_\+sum} & The sum of the number of measurements per parameter \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{20                                       \{}
\DoxyCodeLine{21 }
\DoxyCodeLine{22     bound\_track\_parameters\_collection\_types::const\_device params(params\_view);}
\DoxyCodeLine{23     vecmem::device\_vector<const detray::geometry::barcode> barcodes(}
\DoxyCodeLine{24         barcodes\_view);}
\DoxyCodeLine{25     vecmem::device\_vector<const unsigned int> upper\_bounds(upper\_bounds\_view);}
\DoxyCodeLine{26     vecmem::device\_vector<unsigned int> n\_measurements(n\_measurements\_view);}
\DoxyCodeLine{27     vecmem::device\_vector<unsigned int> ref\_meas\_idx(ref\_meas\_idx\_view);}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{keywordflow}{if} (globalIndex >= n\_in\_params) \{}
\DoxyCodeLine{30         \textcolor{keywordflow}{return};}
\DoxyCodeLine{31     \}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     \textcolor{comment}{// Get barcode}}
\DoxyCodeLine{34     \textcolor{keyword}{const} \textcolor{keyword}{auto} bcd = params.at(globalIndex).surface\_link();}
\DoxyCodeLine{35     \textcolor{keyword}{const} \textcolor{keyword}{auto} lo =}
\DoxyCodeLine{36         thrust::lower\_bound(thrust::seq, barcodes.begin(), barcodes.end(), bcd);}
\DoxyCodeLine{37     \textcolor{keyword}{const} \textcolor{keyword}{auto} bcd\_id = std::distance(barcodes.begin(), lo);}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{comment}{// Get the reference measurement index and the number of measurements per}}
\DoxyCodeLine{40     \textcolor{comment}{// parameter}}
\DoxyCodeLine{41     ref\_meas\_idx.at(globalIndex) =}
\DoxyCodeLine{42         lo == barcodes.begin() ? 0u : upper\_bounds[bcd\_id -\/ 1];}
\DoxyCodeLine{43     n\_measurements.at(globalIndex) =}
\DoxyCodeLine{44         upper\_bounds[bcd\_id] -\/ ref\_meas\_idx.at(globalIndex);}
\DoxyCodeLine{45 }
\DoxyCodeLine{46     \textcolor{comment}{// Increase the total number of measurements with atomic addition}}
\DoxyCodeLine{47     vecmem::device\_atomic\_ref<unsigned int> n\_meas\_sum(n\_measurements\_sum);}
\DoxyCodeLine{48     n\_meas\_sum.fetch\_add(n\_measurements.at(globalIndex));}
\DoxyCodeLine{49 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetraccc_1_1device_a697e375f53a1b9c334205c81c71746e4}\label{namespacetraccc_1_1device_a697e375f53a1b9c334205c81c71746e4}} 
\index{traccc::device@{traccc::device}!count\_triplets@{count\_triplets}}
\index{count\_triplets@{count\_triplets}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{count\_triplets()}{count\_triplets()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::count\+\_\+triplets (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&}]{config,  }\item[{const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&}]{sp\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{dc\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{mid\+\_\+bot\+\_\+doublet\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{mid\+\_\+top\+\_\+doublet\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::view}}}]{sp\+M\+\_\+tc,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::view}}}]{mb\+\_\+tc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for calculating the number of spacepoint triplets

The count is necessary for allocating the appropriate amount of memory for storing the information of the candidates in a next step.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em config} & Seedfinder configuration \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+\_\+view} & The spacepoint grid to count triplets on \\
\hline
\mbox{\texttt{ in}}  & {\em dc\+\_\+view} & Collection of doublet counters \\
\hline
\mbox{\texttt{ in}}  & {\em mid\+\_\+bot\+\_\+doublet\+\_\+view} & Collection storing the mid\+Bot doublets \\
\hline
\mbox{\texttt{ in}}  & {\em mid\+\_\+top\+\_\+doublet\+\_\+view} & Collection storing the mid\+Top doublets \\
\hline
\mbox{\texttt{ out}}  & {\em sp\+M\+\_\+tc} & Collection storing the number of triplets per middle spacepoint \\
\hline
\mbox{\texttt{ out}}  & {\em mb\+\_\+tc} & Collection storing the number of triplets per mid\+Bottom doublet \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{26                                                      \{}
\DoxyCodeLine{27 }
\DoxyCodeLine{28     \textcolor{comment}{// Create device copy of input parameters}}
\DoxyCodeLine{29     \textcolor{keyword}{const} device\_doublet\_collection\_types::const\_device mid\_bot\_doublet\_device(}
\DoxyCodeLine{30         mid\_bot\_doublet\_view);}
\DoxyCodeLine{31     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{32     \textcolor{keywordflow}{if} (globalIndex >= mid\_bot\_doublet\_device.size()) \{}
\DoxyCodeLine{33         \textcolor{keywordflow}{return};}
\DoxyCodeLine{34     \}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36     \textcolor{comment}{// Get current mid bottom doublet}}
\DoxyCodeLine{37     \textcolor{keyword}{const} device\_doublet mid\_bot = mid\_bot\_doublet\_device.at(globalIndex);}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{comment}{// Create device copy of input parameters}}
\DoxyCodeLine{40     \textcolor{keyword}{const} device\_doublet\_collection\_types::const\_device mid\_top\_doublet\_device(}
\DoxyCodeLine{41         mid\_top\_doublet\_view);}
\DoxyCodeLine{42     \textcolor{keyword}{const} doublet\_counter\_collection\_types::const\_device dc\_device(dc\_view);}
\DoxyCodeLine{43 }
\DoxyCodeLine{44     \textcolor{comment}{// Create device copy of output parameterss}}
\DoxyCodeLine{45     triplet\_counter\_collection\_types::device mb\_triplet\_counter(mb\_tc\_view);}
\DoxyCodeLine{46     triplet\_counter\_spM\_collection\_types::device spM\_triplet\_counter(}
\DoxyCodeLine{47         spM\_tc\_view);}
\DoxyCodeLine{48 }
\DoxyCodeLine{49     \textcolor{comment}{// Get all spacepoints}}
\DoxyCodeLine{50     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_afdad33573f6399c7e2671b6968dfc29c}{const\_sp\_grid\_device}} internal\_sp\_device(sp\_view);}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} counter\_link = mid\_bot.counter\_link;}
\DoxyCodeLine{53     \textcolor{keyword}{const} doublet\_counter doublet\_counts = dc\_device.at(counter\_link);}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{comment}{// middle spacepoint}}
\DoxyCodeLine{56     \textcolor{keyword}{const} sp\_location spM\_loc = doublet\_counts.m\_spM;}
\DoxyCodeLine{57     \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} spM =}
\DoxyCodeLine{58         internal\_sp\_device.bin(spM\_loc.bin\_idx)[spM\_loc.sp\_idx];}
\DoxyCodeLine{59     \textcolor{keyword}{const} sp\_location spB\_loc = mid\_bot.sp2;}
\DoxyCodeLine{60     \textcolor{comment}{// bottom spacepoint}}
\DoxyCodeLine{61     \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} spB =}
\DoxyCodeLine{62         internal\_sp\_device.bin(spB\_loc.bin\_idx)[spB\_loc.sp\_idx];}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     \textcolor{comment}{// Apply the conformal transformation to middle-\/bot doublet}}
\DoxyCodeLine{65     \mbox{\hyperlink{structtraccc_1_1lin__circle}{traccc::lin\_circle}} lb = doublet\_finding\_helper::transform\_coordinates<}
\DoxyCodeLine{66         details::spacepoint\_type::bottom>(spM, spB);}
\DoxyCodeLine{67 }
\DoxyCodeLine{68     \textcolor{comment}{// Calculate some physical quantities required for triplet compatibility}}
\DoxyCodeLine{69     \textcolor{comment}{// check}}
\DoxyCodeLine{70     \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} iSinTheta2 = \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}}\textcolor{keyword}{>}(1.) + lb.\mbox{\hyperlink{structtraccc_1_1lin__circle_abff2aeab6abec38b620888e6c0b54a52}{cotTheta}}() * lb.\mbox{\hyperlink{structtraccc_1_1lin__circle_abff2aeab6abec38b620888e6c0b54a52}{cotTheta}}();}
\DoxyCodeLine{71     \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} scatteringInRegion2 = config.maxScatteringAngle2 * iSinTheta2;}
\DoxyCodeLine{72     scatteringInRegion2 *= config.sigmaScattering * config.sigmaScattering;}
\DoxyCodeLine{73 }
\DoxyCodeLine{74     \textcolor{comment}{// These two quantities are used as output parameters in}}
\DoxyCodeLine{75     \textcolor{comment}{// triplet\_finding\_helper::isCompatible but their values are irrelevant}}
\DoxyCodeLine{76     \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} curvature, impact\_parameter;}
\DoxyCodeLine{77 }
\DoxyCodeLine{78     \textcolor{comment}{// find the reference (start) index of the mid-\/top doublet container}}
\DoxyCodeLine{79     \textcolor{comment}{// item vector, where the doublets are recorded}}
\DoxyCodeLine{80     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mt\_start\_idx = doublet\_counts.m\_posMidTop;}
\DoxyCodeLine{81     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mt\_end\_idx = mt\_start\_idx + doublet\_counts.m\_nMidTop;}
\DoxyCodeLine{82 }
\DoxyCodeLine{83     \textcolor{comment}{// number of triplets per middle-\/bot doublet}}
\DoxyCodeLine{84     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num\_triplets\_per\_mb = 0;}
\DoxyCodeLine{85 }
\DoxyCodeLine{86     \textcolor{comment}{// iterate over mid-\/top doublets}}
\DoxyCodeLine{87     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = mt\_start\_idx; i < mt\_end\_idx; ++i) \{}
\DoxyCodeLine{88         \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1sp__location}{traccc::sp\_location}} spT\_loc = mid\_top\_doublet\_device[i].sp2;}
\DoxyCodeLine{89 }
\DoxyCodeLine{90         \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} spT =}
\DoxyCodeLine{91             internal\_sp\_device.bin(spT\_loc.\mbox{\hyperlink{structtraccc_1_1sp__location_a0de6f50bcf35a0a0f62b1dc00d587a55}{bin\_idx}})[spT\_loc.\mbox{\hyperlink{structtraccc_1_1sp__location_a2c5869bc5537dc06273a672e2e09bf70}{sp\_idx}}];}
\DoxyCodeLine{92 }
\DoxyCodeLine{93         \textcolor{comment}{// Apply the conformal transformation to middle-\/top doublet}}
\DoxyCodeLine{94         \mbox{\hyperlink{structtraccc_1_1lin__circle}{traccc::lin\_circle}} lt = doublet\_finding\_helper::transform\_coordinates<}
\DoxyCodeLine{95             details::spacepoint\_type::top>(spM, spT);}
\DoxyCodeLine{96 }
\DoxyCodeLine{97         \textcolor{comment}{// Check if mid-\/bot and mid-\/top doublets can form a triplet}}
\DoxyCodeLine{98         \textcolor{keywordflow}{if} (triplet\_finding\_helper::isCompatible(}
\DoxyCodeLine{99                 spM, lb, lt, config, iSinTheta2, scatteringInRegion2, curvature,}
\DoxyCodeLine{100                 impact\_parameter)) \{}
\DoxyCodeLine{101             num\_triplets\_per\_mb++;}
\DoxyCodeLine{102         \}}
\DoxyCodeLine{103     \}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105     \textcolor{comment}{// if the number of triplets per mb is larger than 0, write the triplet}}
\DoxyCodeLine{106     \textcolor{comment}{// counter into the collection}}
\DoxyCodeLine{107     \textcolor{keywordflow}{if} (num\_triplets\_per\_mb > 0) \{}
\DoxyCodeLine{108         triplet\_counter\_spM\& header = spM\_triplet\_counter.at(counter\_link);}
\DoxyCodeLine{109         vecmem::device\_atomic\_ref<unsigned int> nTriplets(header.m\_nTriplets);}
\DoxyCodeLine{110         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} posTriplets =}
\DoxyCodeLine{111             nTriplets.fetch\_add(num\_triplets\_per\_mb);}
\DoxyCodeLine{112 }
\DoxyCodeLine{113         mb\_triplet\_counter.push\_back(}
\DoxyCodeLine{114             \{spB\_loc, counter\_link, num\_triplets\_per\_mb, posTriplets\});}
\DoxyCodeLine{115     \}}
\DoxyCodeLine{116 \}}

\end{DoxyCode}


References traccc\+::sp\+\_\+location\+::bin\+\_\+idx, traccc\+::details\+::bottom, traccc\+::lin\+\_\+circle\+::cot\+Theta(), traccc\+::device\+::device\+\_\+doublet\+::counter\+\_\+link, traccc\+::triplet\+\_\+finding\+\_\+helper\+::is\+Compatible(), traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+n\+Mid\+Top, traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::m\+\_\+n\+Triplets, traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+pos\+Mid\+Top, traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+spM, traccc\+::seedfinder\+\_\+config\+::max\+Scattering\+Angle2, traccc\+::seedfinder\+\_\+config\+::sigma\+Scattering, traccc\+::device\+::device\+\_\+doublet\+::sp2, traccc\+::sp\+\_\+location\+::sp\+\_\+idx, traccc\+::details\+::top, and traccc\+::doublet\+\_\+finding\+\_\+helper\+::transform\+\_\+coordinates().

\mbox{\Hypertarget{namespacetraccc_1_1device_af41f49ac70ec91a9e0065d1586027506}\label{namespacetraccc_1_1device_af41f49ac70ec91a9e0065d1586027506}} 
\index{traccc::device@{traccc::device}!estimate\_track\_params@{estimate\_track\_params}}
\index{estimate\_track\_params@{estimate\_track\_params}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{estimate\_track\_params()}{estimate\_track\_params()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::estimate\+\_\+track\+\_\+params (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{spacepoints\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{seed\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{seeds\+\_\+view,  }\item[{const \mbox{\hyperlink{namespacetraccc_a3e92464c509aa7ac245244b6083357c2}{vector3}} \&}]{bfield,  }\item[{const std\+::array$<$ \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{traccc\+::scalar}}, \mbox{\hyperlink{namespacetraccc_a65f3496a079e9bdcffaf1d62a5fa4151af60fe71ca99e61d0a0d70fb431aabc04}{traccc\+::e\+\_\+bound\+\_\+size}} $>$ \&}]{stddev,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}}}]{params\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for calculating the bound track parameters for each seed


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em spacepoints\+\_\+view} & Collection storing the spacepoints \\
\hline
\mbox{\texttt{ in}}  & {\em seeds\+\_\+view} & Collection storing the seeds \\
\hline
\mbox{\texttt{ in}}  & {\em bfield} & B field \\
\hline
\mbox{\texttt{ in}}  & {\em stddev} & Standard deviation of seed parameters \\
\hline
\mbox{\texttt{ out}}  & {\em params\+\_\+view} & Collection storing the bound track parameters \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{22                                                              \{}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{25     \textcolor{keyword}{const} seed\_collection\_types::const\_device seeds\_device(seeds\_view);}
\DoxyCodeLine{26     \textcolor{keywordflow}{if} (globalIndex >= seeds\_device.size()) \{}
\DoxyCodeLine{27         \textcolor{keywordflow}{return};}
\DoxyCodeLine{28     \}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30     \textcolor{keyword}{const} spacepoint\_collection\_types::const\_device spacepoints\_device(}
\DoxyCodeLine{31         spacepoints\_view);}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     bound\_track\_parameters\_collection\_types::device params\_device(params\_view);}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{keyword}{const} seed\& this\_seed = seeds\_device.at(globalIndex);}
\DoxyCodeLine{36 }
\DoxyCodeLine{37     \textcolor{comment}{// Get bound track parameter}}
\DoxyCodeLine{38     \mbox{\hyperlink{namespacetraccc_a49b1ec1e09c6b63a918d97428dd51f2e}{bound\_track\_parameters}} track\_params;}
\DoxyCodeLine{39     track\_params.set\_vector(\mbox{\hyperlink{namespacetraccc_a88606a40b404017f29254d1316716919}{seed\_to\_bound\_vector}}(spacepoints\_device, this\_seed,}
\DoxyCodeLine{40                                                  bfield, \mbox{\hyperlink{namespacetraccc_a6cf70f42326684dce8af8f18664292af}{PION\_MASS\_MEV}}));}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{comment}{// Set Covariance}}
\DoxyCodeLine{43     \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \mbox{\hyperlink{namespacetraccc_a65f3496a079e9bdcffaf1d62a5fa4151af60fe71ca99e61d0a0d70fb431aabc04}{e\_bound\_size}}; i++) \{}
\DoxyCodeLine{44         getter::element(track\_params.covariance(), i, i) =}
\DoxyCodeLine{45             stddev[i] * stddev[i];}
\DoxyCodeLine{46     \}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{comment}{// Get geometry ID for bottom spacepoint}}
\DoxyCodeLine{49     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& spB = spacepoints\_device.at(this\_seed.spB\_link);}
\DoxyCodeLine{50     track\_params.set\_surface\_link(spB.meas.surface\_link);}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{comment}{// Save the object into global memory.}}
\DoxyCodeLine{53     params\_device[globalIndex] = track\_params;}
\DoxyCodeLine{54 \}}

\end{DoxyCode}


References traccc\+::e\+\_\+bound\+\_\+size, traccc\+::\+P\+I\+O\+N\+\_\+\+M\+A\+S\+S\+\_\+\+M\+EV, traccc\+::seed\+\_\+to\+\_\+bound\+\_\+vector(), and traccc\+::seed\+::sp\+B\+\_\+link.

\mbox{\Hypertarget{namespacetraccc_1_1device_a2fc626e715c5d48a0d3261d70d479dd5}\label{namespacetraccc_1_1device_a2fc626e715c5d48a0d3261d70d479dd5}} 
\index{traccc::device@{traccc::device}!fast\_sv\_1@{fast\_sv\_1}}
\index{fast\_sv\_1@{fast\_sv\_1}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{fast\_sv\_1()}{fast\_sv\_1()}}
{\footnotesize\ttfamily template$<$typename barrier\+\_\+t $>$ \\
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::fast\+\_\+sv\+\_\+1 (\begin{DoxyParamCaption}\item[{index\+\_\+t $\ast$}]{f,  }\item[{index\+\_\+t $\ast$}]{gf,  }\item[{unsigned char}]{adjc\mbox{[}\+M\+A\+X\+\_\+\+C\+E\+L\+L\+S\+\_\+\+P\+E\+R\+\_\+\+T\+H\+R\+E\+A\+D\mbox{]},  }\item[{index\+\_\+t}]{adjv\mbox{[}\+M\+A\+X\+\_\+\+C\+E\+L\+L\+S\+\_\+\+P\+E\+R\+\_\+\+T\+H\+R\+E\+A\+D\mbox{]}\mbox{[}8\mbox{]},  }\item[{const index\+\_\+t}]{tid,  }\item[{const index\+\_\+t}]{blck\+Dim,  }\item[{barrier\+\_\+t \&}]{barrier }\end{DoxyParamCaption})}

Implementation of a Fast\+SV algorithm with the following steps\+: 1) mix of stochastic and aggressive hooking 2) shortcutting

The implementation corresponds to an adapted versiion of Algorithm 3 of the following paper\+: \href{https://www.sciencedirect.com/science/article/pii/S0743731520302689}{\texttt{ https\+://www.\+sciencedirect.\+com/science/article/pii/\+S0743731520302689}} \begin{DoxyVerb}                This array only gets updated at the end of the iteration
                to prevent race conditions.
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em adjc} & The number of adjacent cells \\
\hline
\mbox{\texttt{ in}}  & {\em adjv} & Vector of adjacent cells \\
\hline
\mbox{\texttt{ in}}  & {\em tid} & The thread index \\
\hline
\mbox{\texttt{ in}}  & {\em blck\+Dim} & The block size \\
\hline
\mbox{\texttt{ in,out}}  & {\em f} & array holding the parent cell ID for the current iteration. \\
\hline
\mbox{\texttt{ in,out}}  & {\em gf} & array holding grandparent cell ID from the previous iteration. \\
\hline
\mbox{\texttt{ in}}  & {\em barrier} & A generic object for block-\/wide synchronisation \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{40                                                  \{}
\DoxyCodeLine{41     \textcolor{comment}{/*}}
\DoxyCodeLine{42 \textcolor{comment}{     * The algorithm finishes if an iteration leaves the arrays unchanged.}}
\DoxyCodeLine{43 \textcolor{comment}{     * This varible will be set if a change is made, and dictates if another}}
\DoxyCodeLine{44 \textcolor{comment}{     * loop is necessary.}}
\DoxyCodeLine{45 \textcolor{comment}{     */}}
\DoxyCodeLine{46     \textcolor{keywordtype}{bool} gf\_changed;}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{49         \textcolor{comment}{/*}}
\DoxyCodeLine{50 \textcolor{comment}{         * Reset the end-\/parameter to false, so we can set it to true if we}}
\DoxyCodeLine{51 \textcolor{comment}{         * make a change to the gf array.}}
\DoxyCodeLine{52 \textcolor{comment}{         */}}
\DoxyCodeLine{53         gf\_changed = \textcolor{keyword}{false};}
\DoxyCodeLine{54 }
\DoxyCodeLine{55         \textcolor{comment}{/*}}
\DoxyCodeLine{56 \textcolor{comment}{         * The algorithm executes in a loop of three distinct parallel}}
\DoxyCodeLine{57 \textcolor{comment}{         * stages. In this first one, a mix of stochastic and aggressive}}
\DoxyCodeLine{58 \textcolor{comment}{         * hooking, we examine adjacent cells and copy their grand parents}}
\DoxyCodeLine{59 \textcolor{comment}{         * cluster ID if it is lower than ours, essentially merging the two}}
\DoxyCodeLine{60 \textcolor{comment}{         * together.}}
\DoxyCodeLine{61 \textcolor{comment}{         */}}
\DoxyCodeLine{62         \textcolor{keywordflow}{for} (index\_t tst = 0; tst < MAX\_CELLS\_PER\_THREAD; ++tst) \{}
\DoxyCodeLine{63             \textcolor{keyword}{const} index\_t cid = tst * blckDim + tid;}
\DoxyCodeLine{64 }
\DoxyCodeLine{65             \_\_builtin\_assume(adjc[tst] <= 8);}
\DoxyCodeLine{66             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} k = 0; k < adjc[tst]; ++k) \{}
\DoxyCodeLine{67                 index\_t q = gf[adjv[tst][k]];}
\DoxyCodeLine{68 }
\DoxyCodeLine{69                 \textcolor{keywordflow}{if} (gf[cid] > q) \{}
\DoxyCodeLine{70                     f[f[cid]] = q;}
\DoxyCodeLine{71                     f[cid] = q;}
\DoxyCodeLine{72                 \}}
\DoxyCodeLine{73             \}}
\DoxyCodeLine{74         \}}
\DoxyCodeLine{75 }
\DoxyCodeLine{76         \textcolor{comment}{/*}}
\DoxyCodeLine{77 \textcolor{comment}{         * Each stage in this algorithm must be preceded by a}}
\DoxyCodeLine{78 \textcolor{comment}{         * synchronization barrier!}}
\DoxyCodeLine{79 \textcolor{comment}{         */}}
\DoxyCodeLine{80         barrier.blockBarrier();}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{preprocessor}{\#pragma unroll}}
\DoxyCodeLine{83         \textcolor{keywordflow}{for} (index\_t tst = 0; tst < MAX\_CELLS\_PER\_THREAD; ++tst) \{}
\DoxyCodeLine{84             \textcolor{keyword}{const} index\_t cid = tst * blckDim + tid;}
\DoxyCodeLine{85             \textcolor{comment}{/*}}
\DoxyCodeLine{86 \textcolor{comment}{             * The second stage is shortcutting, which is an optimisation that}}
\DoxyCodeLine{87 \textcolor{comment}{             * allows us to look at any shortcuts in the cluster IDs that we}}
\DoxyCodeLine{88 \textcolor{comment}{             * can merge without adjacency information.}}
\DoxyCodeLine{89 \textcolor{comment}{             */}}
\DoxyCodeLine{90             \textcolor{keywordflow}{if} (f[cid] > gf[cid]) \{}
\DoxyCodeLine{91                 f[cid] = gf[cid];}
\DoxyCodeLine{92             \}}
\DoxyCodeLine{93         \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95         \textcolor{comment}{/*}}
\DoxyCodeLine{96 \textcolor{comment}{         * Synchronize before the final stage.}}
\DoxyCodeLine{97 \textcolor{comment}{         */}}
\DoxyCodeLine{98         barrier.blockBarrier();}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{preprocessor}{\#pragma unroll}}
\DoxyCodeLine{101         \textcolor{keywordflow}{for} (index\_t tst = 0; tst < MAX\_CELLS\_PER\_THREAD; ++tst) \{}
\DoxyCodeLine{102             \textcolor{keyword}{const} index\_t cid = tst * blckDim + tid;}
\DoxyCodeLine{103             \textcolor{comment}{/*}}
\DoxyCodeLine{104 \textcolor{comment}{             * Update the array for the next generation, keeping track of any}}
\DoxyCodeLine{105 \textcolor{comment}{             * changes we make.}}
\DoxyCodeLine{106 \textcolor{comment}{             */}}
\DoxyCodeLine{107             \textcolor{keywordflow}{if} (gf[cid] != f[f[cid]]) \{}
\DoxyCodeLine{108                 gf[cid] = f[f[cid]];}
\DoxyCodeLine{109                 gf\_changed = \textcolor{keyword}{true};}
\DoxyCodeLine{110             \}}
\DoxyCodeLine{111         \}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113         \textcolor{comment}{/*}}
\DoxyCodeLine{114 \textcolor{comment}{         * To determine whether we need another iteration, we use block}}
\DoxyCodeLine{115 \textcolor{comment}{         * voting mechanics. Each thread checks if it has made any changes}}
\DoxyCodeLine{116 \textcolor{comment}{         * to the arrays, and votes. If any thread votes true, all threads}}
\DoxyCodeLine{117 \textcolor{comment}{         * will return a true value and go to the next iteration. Only if}}
\DoxyCodeLine{118 \textcolor{comment}{         * all threads return false will the loop exit.}}
\DoxyCodeLine{119 \textcolor{comment}{         */}}
\DoxyCodeLine{120     \} \textcolor{keywordflow}{while} (barrier.blockOr(gf\_changed));}
\DoxyCodeLine{121 \}}

\end{DoxyCode}


Referenced by ccl\+\_\+kernel().

\mbox{\Hypertarget{namespacetraccc_1_1device_a7c2b528a06357f0ac89eae726d2b31ca}\label{namespacetraccc_1_1device_a7c2b528a06357f0ac89eae726d2b31ca}} 
\index{traccc::device@{traccc::device}!fill\_prefix\_sum@{fill\_prefix\_sum}}
\index{fill\_prefix\_sum@{fill\_prefix\_sum}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{fill\_prefix\_sum()}{fill\_prefix\_sum()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::fill\+\_\+prefix\+\_\+sum (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{global\+Index,  }\item[{const vecmem\+::data\+::vector\+\_\+view$<$ const \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&}]{sizes\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$}]{ps\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function filling the prefix sum for a \char`\"{}size vector\char`\"{}

This simple function is just meant to translate the received \char`\"{}size vector\char`\"{} into a \char`\"{}prefix sum\char`\"{}. I.\+e. into a list of index pairs that would allow visiting all elements of the jagged vector described by this \char`\"{}size vector\char`\"{}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em sizes\+\_\+view} & View on the sizes of the \char`\"{}inner vectors\char`\"{} of a jagged vector \\
\hline
\mbox{\texttt{ out}}  & {\em ps\+\_\+view} & View on the result vector of index pairs \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{16                                                          \{}
\DoxyCodeLine{17 }
\DoxyCodeLine{18     \textcolor{keyword}{const} vecmem::device\_vector<const prefix\_sum\_size\_t> sizes(sizes\_view);}
\DoxyCodeLine{19     vecmem::device\_vector<prefix\_sum\_element\_t> result(ps\_view);}
\DoxyCodeLine{20 }
\DoxyCodeLine{21     \textcolor{keywordflow}{if} (globalIndex >= sizes.size()) \{}
\DoxyCodeLine{22         \textcolor{keywordflow}{return};}
\DoxyCodeLine{23     \}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\_sum\_size\_t}} previous =}
\DoxyCodeLine{26         (globalIndex == 0) ? 0 : sizes[globalIndex -\/ 1];}
\DoxyCodeLine{27     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\_sum\_size\_t}} current = sizes[globalIndex];}
\DoxyCodeLine{28     \textcolor{keywordflow}{for} (\mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\_sum\_size\_t}} i = 0; i < current -\/ previous; ++i) \{}
\DoxyCodeLine{29         result.at(previous + i) = \{globalIndex, i\};}
\DoxyCodeLine{30     \}}
\DoxyCodeLine{31 \}}

\end{DoxyCode}


Referenced by traccc\+::kokkos\+::make\+\_\+prefix\+\_\+sum\+\_\+buff(), and traccc\+::alpaka\+::\+Prefix\+Sum\+Buff\+Kernel\+::operator()().

\mbox{\Hypertarget{namespacetraccc_1_1device_aaad2fcfe8fb236f1ecb1ac7309370237}\label{namespacetraccc_1_1device_aaad2fcfe8fb236f1ecb1ac7309370237}} 
\index{traccc::device@{traccc::device}!find\_doublets@{find\_doublets}}
\index{find\_doublets@{find\_doublets}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{find\_doublets()}{find\_doublets()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::find\+\_\+doublets (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&}]{config,  }\item[{const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&}]{sp\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{dc\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::view}}}]{mb\+\_\+doublets\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::view}}}]{mt\+\_\+doublets\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function finding all of the spacepoint doublets

Based on the information collected by {\ttfamily \mbox{\hyperlink{namespacetraccc_1_1device_a9b62b54a150cb456973d25f7a5399ddc}{traccc\+::device\+::count\+\_\+doublets}}} it can fill collection with the specific doublet pairs that exist in the event.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em config} & Seedfinder configuration \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+\_\+view} & The spacepoint grid to find doublets on \\
\hline
\mbox{\texttt{ in}}  & {\em dc\+\_\+view} & Collection with the number of doublets to find \\
\hline
\mbox{\texttt{ out}}  & {\em mb\+\_\+doublets\+\_\+view} & Collection of middle-\/bottom doublets \\
\hline
\mbox{\texttt{ out}}  & {\em mt\+\_\+doublets\+\_\+view} & Collection of middle-\/top doublets \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{27                                                           \{}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{30     \textcolor{keyword}{const} doublet\_counter\_collection\_types::const\_device doublet\_counts(}
\DoxyCodeLine{31         dc\_view);}
\DoxyCodeLine{32     \textcolor{keywordflow}{if} (globalIndex >= doublet\_counts.size()) \{}
\DoxyCodeLine{33         \textcolor{keywordflow}{return};}
\DoxyCodeLine{34     \}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36     \textcolor{comment}{// Get the middle spacepoint that we need to be looking at.}}
\DoxyCodeLine{37     \textcolor{keyword}{const} doublet\_counter middle\_sp\_counter = doublet\_counts.at(globalIndex);}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{comment}{// Set up the device containers.}}
\DoxyCodeLine{40     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_afdad33573f6399c7e2671b6968dfc29c}{const\_sp\_grid\_device}} \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}(sp\_view);}
\DoxyCodeLine{41     device\_doublet\_collection\_types::device mb\_doublets(mb\_doublets\_view);}
\DoxyCodeLine{42     device\_doublet\_collection\_types::device mt\_doublets(mt\_doublets\_view);}
\DoxyCodeLine{43 }
\DoxyCodeLine{44     \textcolor{comment}{// Get the spacepoint that we're evaluating in this thread, and treat that}}
\DoxyCodeLine{45     \textcolor{comment}{// as the "middle" spacepoint.}}
\DoxyCodeLine{46     \textcolor{keyword}{const} internal\_spacepoint<spacepoint> middle\_sp =}
\DoxyCodeLine{47         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(middle\_sp\_counter.m\_spM.bin\_idx)}
\DoxyCodeLine{48             .at(middle\_sp\_counter.m\_spM.sp\_idx);}
\DoxyCodeLine{49 }
\DoxyCodeLine{50     \textcolor{comment}{// Find the reference (start) index of the doublet container item vector,}}
\DoxyCodeLine{51     \textcolor{comment}{// where the doublets are recorded.}}
\DoxyCodeLine{52     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mid\_bot\_start\_idx = middle\_sp\_counter.m\_posMidBot;}
\DoxyCodeLine{53     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mid\_top\_start\_idx = middle\_sp\_counter.m\_posMidTop;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{comment}{// The running indices for the middle-\/bottom and middle-\/top pairs.}}
\DoxyCodeLine{56     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mid\_bot\_idx = 0, mid\_top\_idx = 0;}
\DoxyCodeLine{57 }
\DoxyCodeLine{58     \textcolor{comment}{// The the IDs of the neighbouring bins along the phi and Z axes of the}}
\DoxyCodeLine{59     \textcolor{comment}{// grid.}}
\DoxyCodeLine{60     \textcolor{keyword}{const} detray::dindex\_range phi\_bins =}
\DoxyCodeLine{61         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().range(middle\_sp.phi(), config.neighbor\_scope);}
\DoxyCodeLine{62     \textcolor{keyword}{const} detray::dindex\_range z\_bins =}
\DoxyCodeLine{63         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p1().range(middle\_sp.z(), config.neighbor\_scope);}
\DoxyCodeLine{64     assert(z\_bins[0] <= z\_bins[1]);}
\DoxyCodeLine{65 }
\DoxyCodeLine{66     \textcolor{comment}{// Iterate over all of the neighboring phi bins, including the same bin that}}
\DoxyCodeLine{67     \textcolor{comment}{// the middle spacepoint is in. The loop over the phi bins needs to take}}
\DoxyCodeLine{68     \textcolor{comment}{// into account that we may iterate over the "wrap around point" of the}}
\DoxyCodeLine{69     \textcolor{comment}{// axis.}}
\DoxyCodeLine{70     \textcolor{keywordflow}{for} (detray::dindex phi\_bin\_iterator = phi\_bins[0];}
\DoxyCodeLine{71          phi\_bin\_iterator <=}
\DoxyCodeLine{72          (phi\_bins[1] +}
\DoxyCodeLine{73           (phi\_bins[0] > phi\_bins[1] ? \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().n\_bins : 0));}
\DoxyCodeLine{74          ++phi\_bin\_iterator) \{}
\DoxyCodeLine{75 }
\DoxyCodeLine{76         \textcolor{comment}{// Set up the phi bin index that we are actually meant to use inside of}}
\DoxyCodeLine{77         \textcolor{comment}{// the loop. We could also use a modulo operation here, but that would}}
\DoxyCodeLine{78         \textcolor{comment}{// be slightly more expensive in this specific case.}}
\DoxyCodeLine{79         \textcolor{keyword}{const} detray::dindex phi\_bin =}
\DoxyCodeLine{80             (phi\_bin\_iterator >= \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().n\_bins}
\DoxyCodeLine{81                  ? phi\_bin\_iterator -\/ \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().n\_bins}
\DoxyCodeLine{82                  : phi\_bin\_iterator);}
\DoxyCodeLine{83 }
\DoxyCodeLine{84         \textcolor{comment}{// Iterate over all of the neighboring Z bins, including the same bin}}
\DoxyCodeLine{85         \textcolor{comment}{// that the middle spacepoint is in. This is a much easier iteration, as}}
\DoxyCodeLine{86         \textcolor{comment}{// the Z axis does not "wrap around".}}
\DoxyCodeLine{87         \textcolor{keywordflow}{for} (detray::dindex z\_bin = z\_bins[0]; z\_bin <= z\_bins[1]; ++z\_bin) \{}
\DoxyCodeLine{88 }
\DoxyCodeLine{89             \textcolor{comment}{// Ask the grid for all of the spacepoints in this specific bin.}}
\DoxyCodeLine{90             \textcolor{keyword}{typename} \mbox{\hyperlink{namespacetraccc_1_1details_1_1functor_a357582a9a6874cb71ff052105af32ab2}{const\_sp\_grid\_device::serialized\_storage::const\_reference}}}
\DoxyCodeLine{91                 spacepoints = \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(phi\_bin, z\_bin);}
\DoxyCodeLine{92 }
\DoxyCodeLine{93             \textcolor{comment}{// Construct the "single index" that refers to this phi-\/Z bin.}}
\DoxyCodeLine{94             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} other\_bin\_idx =}
\DoxyCodeLine{95                 phi\_bin + z\_bin * \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.axis\_p0().bins();}
\DoxyCodeLine{96 }
\DoxyCodeLine{97             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size = spacepoints.size();}
\DoxyCodeLine{98             \textcolor{comment}{// Loop over all of those spacepoints.}}
\DoxyCodeLine{99             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} other\_sp\_idx = 0; other\_sp\_idx < size;}
\DoxyCodeLine{100                  ++other\_sp\_idx) \{}
\DoxyCodeLine{101 }
\DoxyCodeLine{102                 \textcolor{comment}{// Access the "other spacepoint".}}
\DoxyCodeLine{103                 \textcolor{keyword}{const} internal\_spacepoint<spacepoint> other\_sp =}
\DoxyCodeLine{104                     spacepoints.at(other\_sp\_idx);}
\DoxyCodeLine{105 }
\DoxyCodeLine{106                 \textcolor{comment}{// Check if this spacepoint is a compatible "bottom" spacepoint}}
\DoxyCodeLine{107                 \textcolor{comment}{// to the thread's "middle" spacepoint.}}
\DoxyCodeLine{108                 \textcolor{keywordflow}{if} (doublet\_finding\_helper::isCompatible<}
\DoxyCodeLine{109                         details::spacepoint\_type::bottom>(middle\_sp, other\_sp,}
\DoxyCodeLine{110                                                           config)) \{}
\DoxyCodeLine{111 }
\DoxyCodeLine{112                     \textcolor{comment}{// Add it as a candidate to the middle-\/bottom container.}}
\DoxyCodeLine{113                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} pos = mid\_bot\_start\_idx + mid\_bot\_idx++;}
\DoxyCodeLine{114                     assert(pos < mb\_doublets.size());}
\DoxyCodeLine{115                     mb\_doublets.at(pos) = \{}
\DoxyCodeLine{116                         \{other\_bin\_idx, other\_sp\_idx\},}
\DoxyCodeLine{117                         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(globalIndex)\};}
\DoxyCodeLine{118                 \}}
\DoxyCodeLine{119                 \textcolor{comment}{// Check if this spacepoint is a compatible "top" spacepoint to}}
\DoxyCodeLine{120                 \textcolor{comment}{// the thread's "middle" spacepoint.}}
\DoxyCodeLine{121                 \textcolor{keywordflow}{if} (doublet\_finding\_helper::isCompatible<}
\DoxyCodeLine{122                         details::spacepoint\_type::top>(middle\_sp, other\_sp,}
\DoxyCodeLine{123                                                        config)) \{}
\DoxyCodeLine{124 }
\DoxyCodeLine{125                     \textcolor{comment}{// Add it as a candidate to the middle-\/top container.}}
\DoxyCodeLine{126                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} pos = mid\_top\_start\_idx + mid\_top\_idx++;}
\DoxyCodeLine{127                     assert(pos < mt\_doublets.size());}
\DoxyCodeLine{128                     mt\_doublets.at(pos) = \{}
\DoxyCodeLine{129                         \{other\_bin\_idx, other\_sp\_idx\},}
\DoxyCodeLine{130                         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(globalIndex)\};}
\DoxyCodeLine{131                 \}}
\DoxyCodeLine{132             \}}
\DoxyCodeLine{133         \}}
\DoxyCodeLine{134     \}}
\DoxyCodeLine{135 \}}

\end{DoxyCode}


References traccc\+::sp\+\_\+location\+::bin\+\_\+idx, traccc\+::details\+::bottom, traccc\+::doublet\+\_\+finding\+\_\+helper\+::is\+Compatible(), traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+pos\+Mid\+Bot, traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+pos\+Mid\+Top, traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+spM, traccc\+::seedfinder\+\_\+config\+::neighbor\+\_\+scope, traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::phi(), traccc\+::sp\+\_\+location\+::sp\+\_\+idx, traccc\+::details\+::top, and traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::z().

\mbox{\Hypertarget{namespacetraccc_1_1device_a5a0635de6424316c6518818af669c01a}\label{namespacetraccc_1_1device_a5a0635de6424316c6518818af669c01a}} 
\index{traccc::device@{traccc::device}!find\_tracks@{find\_tracks}}
\index{find\_tracks@{find\_tracks}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{find\_tracks()}{find\_tracks()}}
{\footnotesize\ttfamily template$<$typename detector\+\_\+t , typename config\+\_\+t $>$ \\
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::find\+\_\+tracks (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const config\+\_\+t}]{cfg,  }\item[{typename detector\+\_\+t\+::view\+\_\+type}]{det\+\_\+data,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{measurements\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{in\+\_\+params\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ const unsigned int $>$}]{n\+\_\+measurements\+\_\+prefix\+\_\+sum\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ const unsigned int $>$}]{ref\+\_\+meas\+\_\+idx\+\_\+view,  }\item[{const unsigned int}]{step,  }\item[{const unsigned int \&}]{n\+\_\+max\+\_\+candidates,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}}}]{out\+\_\+params\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ \mbox{\hyperlink{structtraccc_1_1candidate__link}{candidate\+\_\+link}} $>$}]{links\+\_\+view,  }\item[{unsigned int \&}]{n\+\_\+candidates }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function for combinatorial finding. If the chi2 of the measurement $<$ chi2\+\_\+max, its measurement index and the index of the link from the previous step are added to the link container.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em cfg} & Track finding config object \\
\hline
\mbox{\texttt{ in}}  & {\em det\+\_\+data} & Detector view object \\
\hline
\mbox{\texttt{ in}}  & {\em measurements\+\_\+view} & Measurements container view \\
\hline
\mbox{\texttt{ in}}  & {\em upper\+\_\+bounds\+\_\+view} & Upper bounds of measurements unique w.\+r.\+t barcode \\
\hline
\mbox{\texttt{ in}}  & {\em in\+\_\+params\+\_\+view} & Input parameters \\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+measurements\+\_\+prefix\+\_\+sum\+\_\+view} & Prefix sum of the number of measurements per parameter \\
\hline
\mbox{\texttt{ in}}  & {\em ref\+\_\+meas\+\_\+idx\+\_\+view} & The first index of measurements per parameter \\
\hline
\mbox{\texttt{ in}}  & {\em step} & Step index \\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+max\+\_\+candidates} & Number of maximum candidates \\
\hline
\mbox{\texttt{ out}}  & {\em out\+\_\+params\+\_\+view} & Output parameters \\
\hline
\mbox{\texttt{ out}}  & {\em links\+\_\+view} & link container for the current step \\
\hline
\mbox{\texttt{ out}}  & {\em n\+\_\+candidates} & The number of candidates for the current step \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{30                                 \{}
\DoxyCodeLine{31 }
\DoxyCodeLine{32     \textcolor{comment}{// Detector}}
\DoxyCodeLine{33     detector\_t det(det\_data);}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// Measurement}}
\DoxyCodeLine{36     measurement\_collection\_types::const\_device measurements(measurements\_view);}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \textcolor{comment}{// Input parameters}}
\DoxyCodeLine{39     bound\_track\_parameters\_collection\_types::const\_device in\_params(}
\DoxyCodeLine{40         in\_params\_view);}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{comment}{// Output parameters}}
\DoxyCodeLine{43     bound\_track\_parameters\_collection\_types::device out\_params(out\_params\_view);}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     \textcolor{comment}{// Links}}
\DoxyCodeLine{46     vecmem::device\_vector<candidate\_link> links(links\_view);}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{comment}{// Prefix sum of the number of measurements per parameter}}
\DoxyCodeLine{49     vecmem::device\_vector<const unsigned int> n\_measurements\_prefix\_sum(}
\DoxyCodeLine{50         n\_measurements\_prefix\_sum\_view);}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{comment}{// Reference (first) measurement index per parameter}}
\DoxyCodeLine{53     vecmem::device\_vector<const unsigned int> ref\_meas\_idx(ref\_meas\_idx\_view);}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{comment}{// Last step ID}}
\DoxyCodeLine{56     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} previous\_step =}
\DoxyCodeLine{57         (step == 0) ? std::numeric\_limits<unsigned int>::max() : step -\/ 1;}
\DoxyCodeLine{58 }
\DoxyCodeLine{59     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_measurements\_sum = n\_measurements\_prefix\_sum.back();}
\DoxyCodeLine{60     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stride = globalIndex * cfg.n\_measurements\_per\_thread;}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     vecmem::device\_vector<const unsigned int>::iterator lo1;}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i\_meas = 0; i\_meas < cfg.n\_measurements\_per\_thread;}
\DoxyCodeLine{65          i\_meas++) \{}
\DoxyCodeLine{66         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} idx = stride + i\_meas;}
\DoxyCodeLine{67 }
\DoxyCodeLine{68         \textcolor{keywordflow}{if} (idx >= n\_measurements\_sum) \{}
\DoxyCodeLine{69             \textcolor{keywordflow}{break};}
\DoxyCodeLine{70         \}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72         \textcolor{keywordflow}{if} (i\_meas == 0 || idx == *lo1) \{}
\DoxyCodeLine{73             lo1 = thrust::lower\_bound(thrust::seq,}
\DoxyCodeLine{74                                       n\_measurements\_prefix\_sum.begin(),}
\DoxyCodeLine{75                                       n\_measurements\_prefix\_sum.end(), idx + 1);}
\DoxyCodeLine{76         \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} in\_param\_id =}
\DoxyCodeLine{79             std::distance(n\_measurements\_prefix\_sum.begin(), lo1);}
\DoxyCodeLine{80         \textcolor{keyword}{const} detray::geometry::barcode bcd =}
\DoxyCodeLine{81             in\_params.at(in\_param\_id).surface\_link();}
\DoxyCodeLine{82         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} offset =}
\DoxyCodeLine{83             lo1 == n\_measurements\_prefix\_sum.begin() ? idx : idx -\/ *(lo1 -\/ 1);}
\DoxyCodeLine{84         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} meas\_idx = ref\_meas\_idx.at(in\_param\_id) + offset;}
\DoxyCodeLine{85         \mbox{\hyperlink{namespacetraccc_a49b1ec1e09c6b63a918d97428dd51f2e}{bound\_track\_parameters}} in\_par = in\_params.at(in\_param\_id);}
\DoxyCodeLine{86 }
\DoxyCodeLine{87         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& meas = measurements.at(meas\_idx);}
\DoxyCodeLine{88         track\_state<typename detector\_t::transform3> trk\_state(meas);}
\DoxyCodeLine{89         \textcolor{keyword}{const} detray::surface<detector\_t> sf\{det, bcd\};}
\DoxyCodeLine{90 }
\DoxyCodeLine{91         \textcolor{comment}{// Run the Kalman update}}
\DoxyCodeLine{92         sf.template visit\_mask<}
\DoxyCodeLine{93             gain\_matrix\_updater<typename detector\_t::transform3>>(trk\_state,}
\DoxyCodeLine{94                                                                   in\_par);}
\DoxyCodeLine{95         \textcolor{comment}{// Get the chi-\/square}}
\DoxyCodeLine{96         \textcolor{keyword}{const} \textcolor{keyword}{auto} chi2 = trk\_state.filtered\_chi2();}
\DoxyCodeLine{97 }
\DoxyCodeLine{98         \textcolor{keywordflow}{if} (chi2 < cfg.chi2\_max) \{}
\DoxyCodeLine{99 }
\DoxyCodeLine{100             \textcolor{comment}{// Add measurement candidates to link}}
\DoxyCodeLine{101             vecmem::device\_atomic\_ref<unsigned int> num\_candidates(}
\DoxyCodeLine{102                 n\_candidates);}
\DoxyCodeLine{103 }
\DoxyCodeLine{104             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} l\_pos = num\_candidates.fetch\_add(1);}
\DoxyCodeLine{105 }
\DoxyCodeLine{106             \textcolor{keywordflow}{if} (l\_pos >= n\_max\_candidates) \{}
\DoxyCodeLine{107                 n\_candidates = n\_max\_candidates;}
\DoxyCodeLine{108                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{109             \}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111             links[l\_pos] = \{\{previous\_step, in\_param\_id\}, meas\_idx\};}
\DoxyCodeLine{112 }
\DoxyCodeLine{113             out\_params[l\_pos] = trk\_state.filtered();}
\DoxyCodeLine{114         \}}
\DoxyCodeLine{115     \}}
\DoxyCodeLine{116 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetraccc_1_1device_aac06f2e5b055c83e3ef9362207f325b3}\label{namespacetraccc_1_1device_aac06f2e5b055c83e3ef9362207f325b3}} 
\index{traccc::device@{traccc::device}!find\_triplets@{find\_triplets}}
\index{find\_triplets@{find\_triplets}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{find\_triplets()}{find\_triplets()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::find\+\_\+triplets (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&}]{config,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfilter__config}{seedfilter\+\_\+config}} \&}]{filter\+\_\+config,  }\item[{const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&}]{sp\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{dc\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+doublet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{mid\+\_\+top\+\_\+doublet\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{sp\+M\+\_\+tc\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{tc\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+triplet\+\_\+collection\+\_\+types\+::view}}}]{triplet\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function finding all of the spacepoint triplets

Based on the information collected by {\ttfamily \mbox{\hyperlink{namespacetraccc_1_1device_a697e375f53a1b9c334205c81c71746e4}{traccc\+::device\+::count\+\_\+triplets}}} it can fill collection with the specific triplets that exist in the event.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em config} & Seedfinder configuration \\
\hline
\mbox{\texttt{ in}}  & {\em filter\+\_\+config} & Seedfilter configuration \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+\_\+view} & The spacepoint grid to find triplets on \\
\hline
\mbox{\texttt{ in}}  & {\em dc\+\_\+view} & Collection of doublet counters \\
\hline
\mbox{\texttt{ in}}  & {\em mid\+\_\+top\+\_\+doublet\+\_\+view} & Collection with the mid top doublets \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+M\+\_\+tc\+\_\+view} & Collection with the number of triplets per spM \\
\hline
\mbox{\texttt{ in}}  & {\em tc\+\_\+view} & Collection with the number of triplets per mid\+Bot doublet \\
\hline
\mbox{\texttt{ out}}  & {\em triplet\+\_\+view} & Collection of triplets \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{26                                                       \{}
\DoxyCodeLine{27 }
\DoxyCodeLine{28     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{29     \textcolor{keyword}{const} triplet\_counter\_collection\_types::const\_device triplet\_counts(}
\DoxyCodeLine{30         tc\_view);}
\DoxyCodeLine{31     \textcolor{keywordflow}{if} (globalIndex >= triplet\_counts.size()) \{}
\DoxyCodeLine{32         \textcolor{keywordflow}{return};}
\DoxyCodeLine{33     \}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// Get device copy of input parameters}}
\DoxyCodeLine{36     \textcolor{keyword}{const} doublet\_counter\_collection\_types::const\_device doublet\_counts(}
\DoxyCodeLine{37         dc\_view);}
\DoxyCodeLine{38     \textcolor{keyword}{const} device\_doublet\_collection\_types::const\_device mid\_top\_doublet\_device(}
\DoxyCodeLine{39         mid\_top\_doublet\_view);}
\DoxyCodeLine{40     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_afdad33573f6399c7e2671b6968dfc29c}{const\_sp\_grid\_device}} \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}(sp\_view);}
\DoxyCodeLine{41     \textcolor{keyword}{const} triplet\_counter\_spM\_collection\_types::const\_device triplet\_counts\_spM(}
\DoxyCodeLine{42         spM\_tc\_view);}
\DoxyCodeLine{43 }
\DoxyCodeLine{44     \textcolor{comment}{// Get the current work item information}}
\DoxyCodeLine{45     \textcolor{keyword}{const} triplet\_counter mid\_bot\_counter = triplet\_counts.at(globalIndex);}
\DoxyCodeLine{46     \textcolor{keyword}{const} triplet\_counter\_spM spM\_counter =}
\DoxyCodeLine{47         triplet\_counts\_spM.at(mid\_bot\_counter.spM\_counter\_link);}
\DoxyCodeLine{48     \textcolor{keyword}{const} doublet\_counter doublet\_count =}
\DoxyCodeLine{49         doublet\_counts.at(mid\_bot\_counter.spM\_counter\_link);}
\DoxyCodeLine{50 }
\DoxyCodeLine{51     \textcolor{keyword}{const} sp\_location spM\_loc = spM\_counter.spM;}
\DoxyCodeLine{52     \textcolor{keyword}{const} sp\_location spB\_loc = mid\_bot\_counter.spB;}
\DoxyCodeLine{53 }
\DoxyCodeLine{54     \textcolor{comment}{// middle spacepoint}}
\DoxyCodeLine{55     \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} spM =}
\DoxyCodeLine{56         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(spM\_loc.bin\_idx)[spM\_loc.sp\_idx];}
\DoxyCodeLine{57 }
\DoxyCodeLine{58     \textcolor{comment}{// bottom spacepoint}}
\DoxyCodeLine{59     \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} spB =}
\DoxyCodeLine{60         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(spB\_loc.bin\_idx)[spB\_loc.sp\_idx];}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{comment}{// Set up the device result collection}}
\DoxyCodeLine{63     device\_triplet\_collection\_types::device triplets(triplet\_view);}
\DoxyCodeLine{64 }
\DoxyCodeLine{65     \textcolor{comment}{// Apply the conformal transformation to middle-\/bot doublet}}
\DoxyCodeLine{66     \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1lin__circle}{traccc::lin\_circle}} lb = doublet\_finding\_helper::transform\_coordinates<}
\DoxyCodeLine{67         details::spacepoint\_type::bottom>(spM, spB);}
\DoxyCodeLine{68 }
\DoxyCodeLine{69     \textcolor{comment}{// Calculate some physical quantities required for triplet compatibility}}
\DoxyCodeLine{70     \textcolor{comment}{// check}}
\DoxyCodeLine{71     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} iSinTheta2 = 1 + lb.\mbox{\hyperlink{structtraccc_1_1lin__circle_abff2aeab6abec38b620888e6c0b54a52}{cotTheta}}() * lb.\mbox{\hyperlink{structtraccc_1_1lin__circle_abff2aeab6abec38b620888e6c0b54a52}{cotTheta}}();}
\DoxyCodeLine{72     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} scatteringInRegion2 = config.maxScatteringAngle2 * iSinTheta2 *}
\DoxyCodeLine{73                                        config.sigmaScattering *}
\DoxyCodeLine{74                                        config.sigmaScattering;}
\DoxyCodeLine{75 }
\DoxyCodeLine{76     \textcolor{comment}{// These two quantities are used as output parameters in}}
\DoxyCodeLine{77     \textcolor{comment}{// triplet\_finding\_helper::isCompatible but their values are irrelevant}}
\DoxyCodeLine{78     \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} curvature, impact\_parameter;}
\DoxyCodeLine{79 }
\DoxyCodeLine{80     \textcolor{comment}{// find the reference (start) index of the mid-\/top doublet collection}}
\DoxyCodeLine{81     \textcolor{comment}{// item vector, where the doublets are recorded}}
\DoxyCodeLine{82     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mt\_start\_idx = doublet\_count.m\_posMidTop;}
\DoxyCodeLine{83     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mt\_end\_idx = mt\_start\_idx + doublet\_count.m\_nMidTop;}
\DoxyCodeLine{84     \textcolor{comment}{// The position in which these triplets should be filled is the sum of the}}
\DoxyCodeLine{85     \textcolor{comment}{// position for all triplets which share the same middle spacepoint}}
\DoxyCodeLine{86     \textcolor{comment}{// and the one for those which also share the same bottom spacepoint.}}
\DoxyCodeLine{87     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} posTriplets =}
\DoxyCodeLine{88         mid\_bot\_counter.posTriplets + spM\_counter.posTriplets;}
\DoxyCodeLine{89 }
\DoxyCodeLine{90     \textcolor{comment}{// iterate over mid-\/top doublets}}
\DoxyCodeLine{91     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = mt\_start\_idx; i < mt\_end\_idx; ++i) \{}
\DoxyCodeLine{92         \textcolor{keyword}{const} sp\_location spT\_loc = mid\_top\_doublet\_device[i].sp2;}
\DoxyCodeLine{93 }
\DoxyCodeLine{94         \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} spT =}
\DoxyCodeLine{95             \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(spT\_loc.bin\_idx)[spT\_loc.sp\_idx];}
\DoxyCodeLine{96 }
\DoxyCodeLine{97         \textcolor{comment}{// Apply the conformal transformation to middle-\/top doublet}}
\DoxyCodeLine{98         \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1lin__circle}{traccc::lin\_circle}} lt =}
\DoxyCodeLine{99             doublet\_finding\_helper::transform\_coordinates<}
\DoxyCodeLine{100                 details::spacepoint\_type::top>(spM, spT);}
\DoxyCodeLine{101 }
\DoxyCodeLine{102         \textcolor{comment}{// Check if mid-\/bot and mid-\/top doublets can form a triplet}}
\DoxyCodeLine{103         \textcolor{keywordflow}{if} (triplet\_finding\_helper::isCompatible(}
\DoxyCodeLine{104                 spM, lb, lt, config, iSinTheta2, scatteringInRegion2, curvature,}
\DoxyCodeLine{105                 impact\_parameter)) \{}
\DoxyCodeLine{106 }
\DoxyCodeLine{107             \textcolor{comment}{// Add triplet to jagged vector}}
\DoxyCodeLine{108             triplets.at(posTriplets++) = device\_triplet(}
\DoxyCodeLine{109                 \{spT\_loc, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(globalIndex), curvature,}
\DoxyCodeLine{110                  -\/impact\_parameter * filter\_config.impactWeightFactor,}
\DoxyCodeLine{111                  lb.\mbox{\hyperlink{structtraccc_1_1lin__circle_ab35afbdb99bb552cc8a85cf517aabfbc}{Zo}}()\});}
\DoxyCodeLine{112         \}}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114 \}}

\end{DoxyCode}


References traccc\+::sp\+\_\+location\+::bin\+\_\+idx, traccc\+::details\+::bottom, traccc\+::lin\+\_\+circle\+::cot\+Theta(), traccc\+::seedfilter\+\_\+config\+::impact\+Weight\+Factor, traccc\+::triplet\+\_\+finding\+\_\+helper\+::is\+Compatible(), traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+n\+Mid\+Top, traccc\+::device\+::doublet\+\_\+counter\+::m\+\_\+pos\+Mid\+Top, traccc\+::seedfinder\+\_\+config\+::max\+Scattering\+Angle2, traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::pos\+Triplets, traccc\+::device\+::triplet\+\_\+counter\+::pos\+Triplets, traccc\+::seedfinder\+\_\+config\+::sigma\+Scattering, traccc\+::sp\+\_\+location\+::sp\+\_\+idx, traccc\+::device\+::triplet\+\_\+counter\+::spB, traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::spM, traccc\+::device\+::triplet\+\_\+counter\+::sp\+M\+\_\+counter\+\_\+link, traccc\+::details\+::top, traccc\+::doublet\+\_\+finding\+\_\+helper\+::transform\+\_\+coordinates(), and traccc\+::lin\+\_\+circle\+::\+Zo().

\mbox{\Hypertarget{namespacetraccc_1_1device_a97659978710a9e2d389c05b9ee4397ae}\label{namespacetraccc_1_1device_a97659978710a9e2d389c05b9ee4397ae}} 
\index{traccc::device@{traccc::device}!fit@{fit}}
\index{fit@{fit}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{fit()}{fit()}}
{\footnotesize\ttfamily template$<$typename fitter\+\_\+t , typename detector\+\_\+view\+\_\+t $>$ \\
\mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::fit (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{detector\+\_\+view\+\_\+t}]{det\+\_\+data,  }\item[{const typename fitter\+\_\+t\+::bfield\+\_\+type}]{field\+\_\+data,  }\item[{const typename fitter\+\_\+t\+::config\+\_\+type}]{cfg,  }\item[{vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ typename fitter\+\_\+t\+::intersection\+\_\+type $>$}]{nav\+\_\+candidates\+\_\+buffer,  }\item[{\mbox{\hyperlink{structtraccc_1_1container__types_aa6a3c3afb08abf3aad41b6002ef8b48f}{track\+\_\+candidate\+\_\+container\+\_\+types\+::const\+\_\+view}}}]{track\+\_\+candidates\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1container__types_a3344afd1f08f09bcec6d7206d380b26c}{track\+\_\+state\+\_\+container\+\_\+types\+::view}}}]{track\+\_\+states\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for fitting a track for a given track candidates


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em det\+\_\+data} & Detector view object \\
\hline
\mbox{\texttt{ in}}  & {\em nav\+\_\+candidates\+\_\+buffer} & Buffer for navigation candidate objects \\
\hline
\mbox{\texttt{ in}}  & {\em track\+\_\+candidates\+\_\+view} & The input track candidates \\
\hline
\mbox{\texttt{ out}}  & {\em track\+\_\+states\+\_\+view} & The output of fitted track states \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{20                                                        \{}
\DoxyCodeLine{21 }
\DoxyCodeLine{22     \textcolor{keyword}{typename} fitter\_t::detector\_type det(det\_data);}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     vecmem::jagged\_device\_vector<typename fitter\_t::intersection\_type>}
\DoxyCodeLine{25         nav\_candidates(nav\_candidates\_buffer);}
\DoxyCodeLine{26 }
\DoxyCodeLine{27     track\_candidate\_container\_types::const\_device track\_candidates(}
\DoxyCodeLine{28         track\_candidates\_view);}
\DoxyCodeLine{29 }
\DoxyCodeLine{30     track\_state\_container\_types::device track\_states(track\_states\_view);}
\DoxyCodeLine{31 }
\DoxyCodeLine{32     fitter\_t fitter(det, field\_data, cfg);}
\DoxyCodeLine{33 }
\DoxyCodeLine{34     \textcolor{keywordflow}{if} (globalIndex >= track\_states.size()) \{}
\DoxyCodeLine{35         \textcolor{keywordflow}{return};}
\DoxyCodeLine{36     \}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \textcolor{comment}{// Track candidates per track}}
\DoxyCodeLine{39     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& track\_candidates\_per\_track =}
\DoxyCodeLine{40         track\_candidates[globalIndex].items;}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{comment}{// Seed parameter}}
\DoxyCodeLine{43     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& seed\_param = track\_candidates[globalIndex].header;}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     \textcolor{comment}{// Track states per track}}
\DoxyCodeLine{46     \textcolor{keyword}{auto} track\_states\_per\_track = track\_states[globalIndex].items;}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& cand : track\_candidates\_per\_track) \{}
\DoxyCodeLine{49         track\_states\_per\_track.emplace\_back(cand);}
\DoxyCodeLine{50     \}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{keyword}{typename} fitter\_t::state fitter\_state(track\_states\_per\_track);}
\DoxyCodeLine{53 }
\DoxyCodeLine{54     \textcolor{comment}{// Run fitting}}
\DoxyCodeLine{55     fitter.fit(seed\_param, fitter\_state, nav\_candidates.at(globalIndex));}
\DoxyCodeLine{56 }
\DoxyCodeLine{57     \textcolor{comment}{// Get the final fitting information}}
\DoxyCodeLine{58     track\_states[globalIndex].header = fitter\_state.m\_fit\_info;}
\DoxyCodeLine{59 \}}

\end{DoxyCode}


References traccc\+::device\+\_\+container$<$ header\+\_\+t, item\+\_\+t $>$\+::size().

\mbox{\Hypertarget{namespacetraccc_1_1device_ad06299bae21c8e751058d3c70ee6a857}\label{namespacetraccc_1_1device_ad06299bae21c8e751058d3c70ee6a857}} 
\index{traccc::device@{traccc::device}!form\_spacepoints@{form\_spacepoints}}
\index{form\_spacepoints@{form\_spacepoints}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{form\_spacepoints()}{form\_spacepoints()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::form\+\_\+spacepoints (\begin{DoxyParamCaption}\item[{const std\+::size\+\_\+t}]{global\+Index,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{measurements\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{cell\+\_\+module\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{modules\+\_\+view,  }\item[{const unsigned int}]{measurement\+\_\+count,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{spacepoint\+\_\+collection\+\_\+types\+::view}}}]{spacepoints\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function for creating 3D spacepoints out of 2D measurements


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index for the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em measurements\+\_\+view} & Collection of measurements \\
\hline
\mbox{\texttt{ in}}  & {\em modules\+\_\+view} & Collection of modules (which the measurements link to) \\
\hline
\mbox{\texttt{ in}}  & {\em measurement\+\_\+count} & Number of measurements \\
\hline
\mbox{\texttt{ out}}  & {\em spacepoints\+\_\+view} & Collection of spacepoints \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{18                                                       \{}
\DoxyCodeLine{19 }
\DoxyCodeLine{20     \textcolor{comment}{// Get device copy of input parameters}}
\DoxyCodeLine{21     \textcolor{keyword}{const} measurement\_collection\_types::const\_device measurements\_device(}
\DoxyCodeLine{22         measurements\_view);}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     \textcolor{comment}{// Check if anything needs to be done}}
\DoxyCodeLine{25     \textcolor{keywordflow}{if} (globalIndex >= measurement\_count) \{}
\DoxyCodeLine{26         \textcolor{keywordflow}{return};}
\DoxyCodeLine{27     \}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{comment}{// Get device copy of input parameters}}
\DoxyCodeLine{30     \textcolor{keyword}{const} cell\_module\_collection\_types::const\_device modules\_device(}
\DoxyCodeLine{31         modules\_view);}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     spacepoint\_collection\_types::device spacepoints\_device(spacepoints\_view);}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// Get the measurement for this index}}
\DoxyCodeLine{36     \textcolor{keyword}{const} measurement\& meas = measurements\_device.at(globalIndex);}
\DoxyCodeLine{37     \textcolor{comment}{// Get the current cell module}}
\DoxyCodeLine{38     \textcolor{keyword}{const} cell\_module\& mod = modules\_device.at(meas.module\_link);}
\DoxyCodeLine{39     \textcolor{comment}{// Form a spacepoint based on this measurement}}
\DoxyCodeLine{40     \mbox{\hyperlink{namespacetraccc_a7a1ed25524ba151f7ee54cec655fb3f3}{point3}} local\_3d = \{meas.local[0], meas.local[1], 0.\};}
\DoxyCodeLine{41     \mbox{\hyperlink{namespacetraccc_a7a1ed25524ba151f7ee54cec655fb3f3}{point3}} global = mod.placement.point\_to\_global(local\_3d);}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{comment}{// Fill the result object with this spacepoint}}
\DoxyCodeLine{44     spacepoints\_device[globalIndex] = \{global, meas\};}
\DoxyCodeLine{45 \}}

\end{DoxyCode}


References traccc\+::measurement\+::local, traccc\+::measurement\+::module\+\_\+link, and traccc\+::cell\+\_\+module\+::placement.

\mbox{\Hypertarget{namespacetraccc_1_1device_a32c38f509eef5398c63cc66721db1a83}\label{namespacetraccc_1_1device_a32c38f509eef5398c63cc66721db1a83}} 
\index{traccc::device@{traccc::device}!is\_adjacent@{is\_adjacent}}
\index{is\_adjacent@{is\_adjacent}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{is\_adjacent()}{is\_adjacent()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} bool traccc\+::device\+::is\+\_\+adjacent (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}}}]{ac0,  }\item[{\mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}}}]{ac1,  }\item[{\mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}}}]{bc0,  }\item[{\mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\+\_\+id}}}]{bc1 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}


\begin{DoxyCode}{0}
\DoxyCodeLine{18                                         \{}
\DoxyCodeLine{19     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} p0 = (ac0 -\/ bc0);}
\DoxyCodeLine{20     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} p1 = (ac1 -\/ bc1);}
\DoxyCodeLine{21 }
\DoxyCodeLine{22     \textcolor{keywordflow}{return} p0 * p0 <= 1 \&\& p1 * p1 <= 1;}
\DoxyCodeLine{23 \}}

\end{DoxyCode}


Referenced by reduce\+\_\+problem\+\_\+cell().

\mbox{\Hypertarget{namespacetraccc_1_1device_aee8f3ca7cc59d443151e6da536f1fb36}\label{namespacetraccc_1_1device_aee8f3ca7cc59d443151e6da536f1fb36}} 
\index{traccc::device@{traccc::device}!make\_barcode\_sequence@{make\_barcode\_sequence}}
\index{make\_barcode\_sequence@{make\_barcode\_sequence}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{make\_barcode\_sequence()}{make\_barcode\_sequence()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::make\+\_\+barcode\+\_\+sequence (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{measurement\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{uniques\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ detray\+::geometry\+::barcode $>$}]{barcodes\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function filling the barcode sequence


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em uniques\+\_\+view} & Measurement container view object \\
\hline
\mbox{\texttt{ out}}  & {\em barcodes\+\_\+view} & Unsorted module map of $<$module ID, header ID$>$ \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{15                                                                 \{}
\DoxyCodeLine{16 }
\DoxyCodeLine{17     measurement\_collection\_types::const\_device uniques(uniques\_view);}
\DoxyCodeLine{18     vecmem::device\_vector barcodes(barcodes\_view);}
\DoxyCodeLine{19 }
\DoxyCodeLine{20     \textcolor{keywordflow}{if} (globalIndex >= uniques.size()) \{}
\DoxyCodeLine{21         \textcolor{keywordflow}{return};}
\DoxyCodeLine{22     \}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     \textcolor{comment}{// Assign barcode}}
\DoxyCodeLine{25     barcodes.at(globalIndex) = uniques.at(globalIndex).surface\_link;}
\DoxyCodeLine{26 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetraccc_1_1device_a782823d57c341df346a3589010537dbf}\label{namespacetraccc_1_1device_a782823d57c341df346a3589010537dbf}} 
\index{traccc::device@{traccc::device}!make\_prefix\_sum\_buffer@{make\_prefix\_sum\_buffer}}
\index{make\_prefix\_sum\_buffer@{make\_prefix\_sum\_buffer}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{make\_prefix\_sum\_buffer()}{make\_prefix\_sum\_buffer()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a95b39033664ff24e9b2f42ef43041ad0}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+ST}} \mbox{\hyperlink{namespacetraccc_1_1device_a1c67d5b48697c4ad899f28ae69120e33}{prefix\+\_\+sum\+\_\+buffer\+\_\+t}} traccc\+::device\+::make\+\_\+prefix\+\_\+sum\+\_\+buffer (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&}]{sizes,  }\item[{vecmem\+::copy \&}]{copy,  }\item[{const \mbox{\hyperlink{structtraccc_1_1memory__resource}{traccc\+::memory\+\_\+resource}} \&}]{mr }\end{DoxyParamCaption})}

Function providing the prefix sum for a \char`\"{}size vector\char`\"{}

This simple function is just meant to translate the received \char`\"{}size vector\char`\"{} into its prefix sum. I.\+e. Each element of the output vector equals the summation of all the elements up to that point of the input vector


\begin{DoxyParams}{Parameters}
{\em sizes} & The sizes of the \char`\"{}inner vectors\char`\"{} of a jagged vector \\
\hline
{\em copy} & A \char`\"{}copy object\char`\"{} capable of dealing with the view \\
\hline
{\em mr} & The memory resource to use of the result \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A class containing the prefix sum view, a memory posessing object on the view elements, and the total summation of the size vector 
\end{DoxyReturn}

\begin{DoxyCode}{0}
\DoxyCodeLine{19                                      \{}
\DoxyCodeLine{20 }
\DoxyCodeLine{21     \textcolor{keywordflow}{if} (sizes.size() == 0) \{}
\DoxyCodeLine{22         \textcolor{keywordflow}{return} \{\{\}, \{\}, 0\};}
\DoxyCodeLine{23     \}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25     \textcolor{comment}{// Create vector with summation of sizes}}
\DoxyCodeLine{26     vecmem::vector<prefix\_sum\_size\_t> sizes\_sum(sizes.size(),}
\DoxyCodeLine{27                                                 mr.\mbox{\hyperlink{structtraccc_1_1memory__resource_a3a7e6ce915149a10e37a9e9c6d73bf95}{host}} ? mr.\mbox{\hyperlink{structtraccc_1_1memory__resource_a3a7e6ce915149a10e37a9e9c6d73bf95}{host}} : \&(mr.\mbox{\hyperlink{structtraccc_1_1memory__resource_a9f1136a4fdab877dd1bbd1a2996e2149}{main}}));}
\DoxyCodeLine{28     std::partial\_sum(sizes.begin(), sizes.end(), sizes\_sum.begin(),}
\DoxyCodeLine{29                      std::plus<prefix\_sum\_size\_t>());}
\DoxyCodeLine{30     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{prefix\_sum\_size\_t}} totalSize = sizes\_sum.back();}
\DoxyCodeLine{31 }
\DoxyCodeLine{32     \textcolor{keywordflow}{if} (mr.\mbox{\hyperlink{structtraccc_1_1memory__resource_a3a7e6ce915149a10e37a9e9c6d73bf95}{host}} != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{33         \textcolor{comment}{// Create buffer and view objects}}
\DoxyCodeLine{34         vecmem::data::vector\_buffer<prefix\_sum\_size\_t> sizes\_sum\_buff(}
\DoxyCodeLine{35             sizes\_sum.size(), mr.\mbox{\hyperlink{structtraccc_1_1memory__resource_a9f1136a4fdab877dd1bbd1a2996e2149}{main}});}
\DoxyCodeLine{36         copy.setup(sizes\_sum\_buff);}
\DoxyCodeLine{37         (copy)(\mbox{\hyperlink{namespacetraccc_a503d2d50b981602cbc71693ad215b298}{vecmem::get\_data}}(sizes\_sum), sizes\_sum\_buff)-\/>wait();}
\DoxyCodeLine{38         vecmem::data::vector\_view<prefix\_sum\_size\_t> sizes\_sum\_view(}
\DoxyCodeLine{39             sizes\_sum\_buff);}
\DoxyCodeLine{40 }
\DoxyCodeLine{41         \textcolor{keywordflow}{return} \{sizes\_sum\_view, std::move(sizes\_sum\_buff), totalSize\};}
\DoxyCodeLine{42     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{43         \textcolor{comment}{// Create view object}}
\DoxyCodeLine{44         vecmem::data::vector\_view<prefix\_sum\_size\_t> sizes\_sum\_view =}
\DoxyCodeLine{45             \mbox{\hyperlink{namespacetraccc_a503d2d50b981602cbc71693ad215b298}{vecmem::get\_data}}(sizes\_sum);}
\DoxyCodeLine{46 }
\DoxyCodeLine{47         \textcolor{keywordflow}{return} \{sizes\_sum\_view, std::move(sizes\_sum), totalSize\};}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49 \}}

\end{DoxyCode}


References traccc\+::get\+\_\+data(), traccc\+::memory\+\_\+resource\+::host, and traccc\+::memory\+\_\+resource\+::main.



Referenced by traccc\+::kokkos\+::make\+\_\+prefix\+\_\+sum\+\_\+buff(), and traccc\+::alpaka\+::make\+\_\+prefix\+\_\+sum\+\_\+buff().

\mbox{\Hypertarget{namespacetraccc_1_1device_ab5cd1251ac7c7ded70369df125d151e5}\label{namespacetraccc_1_1device_ab5cd1251ac7c7ded70369df125d151e5}} 
\index{traccc::device@{traccc::device}!populate\_grid@{populate\_grid}}
\index{populate\_grid@{populate\_grid}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{populate\_grid()}{populate\_grid()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::populate\+\_\+grid (\begin{DoxyParamCaption}\item[{unsigned int}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfinder__config}{seedfinder\+\_\+config}} \&}]{config,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{spacepoints,  }\item[{\mbox{\hyperlink{namespacetraccc_a5044143e89d8abc4a09e7829850cdfdc}{sp\+\_\+grid\+\_\+view}}}]{grid }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function populating the spacepoint grid


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em config} & Seedfinder configuration \\
\hline
\mbox{\texttt{ in}}  & {\em spacepoints} & All the spacepoints of the event \\
\hline
\mbox{\texttt{ out}}  & {\em grid} & The spacepoint grid to populate \\
\hline
\end{DoxyParams}
Check out if the spacepoint can be used for seeding.
\begin{DoxyCode}{0}
\DoxyCodeLine{19                             \{}
\DoxyCodeLine{20 }
\DoxyCodeLine{21     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{22     \textcolor{keyword}{const} spacepoint\_collection\_types::const\_device spacepoints(}
\DoxyCodeLine{23         spacepoints\_view);}
\DoxyCodeLine{24     \textcolor{keywordflow}{if} (globalIndex >= spacepoints.size()) \{}
\DoxyCodeLine{25         \textcolor{keywordflow}{return};}
\DoxyCodeLine{26     \}}
\DoxyCodeLine{27     \textcolor{keyword}{const} spacepoint sp = spacepoints.at(globalIndex);}
\DoxyCodeLine{28 }
\DoxyCodeLine{30     \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetraccc_a4e12ff4b9f7297ad771d4fe8ecc17304}{is\_valid\_sp}}(config, sp) != detray::detail::invalid\_value<size\_t>()) \{}
\DoxyCodeLine{31 }
\DoxyCodeLine{32         \textcolor{comment}{// Set up the spacepoint grid object(s).}}
\DoxyCodeLine{33         \mbox{\hyperlink{namespacetraccc_afe5550543749e1fde57f965020411065}{sp\_grid\_device}} grid(grid\_view);}
\DoxyCodeLine{34         \textcolor{keyword}{const} sp\_grid\_device::axis\_p0\_type\& phi\_axis = grid.axis\_p0();}
\DoxyCodeLine{35         \textcolor{keyword}{const} sp\_grid\_device::axis\_p1\_type\& z\_axis = grid.axis\_p1();}
\DoxyCodeLine{36 }
\DoxyCodeLine{37         \textcolor{comment}{// Find the grid bin that the spacepoint belongs to.}}
\DoxyCodeLine{38         \textcolor{keyword}{const} internal\_spacepoint<spacepoint> isp(sp, globalIndex,}
\DoxyCodeLine{39                                                   config.beamPos);}
\DoxyCodeLine{40         \textcolor{keyword}{const} std::size\_t bin\_index =}
\DoxyCodeLine{41             phi\_axis.bin(isp.phi()) + phi\_axis.bins() * z\_axis.bin(isp.z());}
\DoxyCodeLine{42 }
\DoxyCodeLine{43         \textcolor{comment}{// Add the spacepoint to the grid.}}
\DoxyCodeLine{44         grid.bin(bin\_index).push\_back(std::move(isp));}
\DoxyCodeLine{45     \}}
\DoxyCodeLine{46 \}}

\end{DoxyCode}


References traccc\+::seedfinder\+\_\+config\+::beam\+Pos, traccc\+::is\+\_\+valid\+\_\+sp(), traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::phi(), and traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::z().



Referenced by traccc\+::kokkos\+::spacepoint\+\_\+binning\+::operator()().

\mbox{\Hypertarget{namespacetraccc_1_1device_a5fbc8641d583065ed1ebc98503d01f10}\label{namespacetraccc_1_1device_a5fbc8641d583065ed1ebc98503d01f10}} 
\index{traccc::device@{traccc::device}!propagate\_to\_next\_surface@{propagate\_to\_next\_surface}}
\index{propagate\_to\_next\_surface@{propagate\_to\_next\_surface}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{propagate\_to\_next\_surface()}{propagate\_to\_next\_surface()}}
{\footnotesize\ttfamily template$<$typename propagator\+\_\+t , typename bfield\+\_\+t , typename config\+\_\+t $>$ \\
\mbox{\hyperlink{qualifiers_8hpp_a95e1c711b776a8c1d0ece5b492f5a5e6}{T\+R\+A\+C\+C\+C\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::propagate\+\_\+to\+\_\+next\+\_\+surface (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const config\+\_\+t}]{cfg,  }\item[{typename propagator\+\_\+t\+::detector\+\_\+type\+::view\+\_\+type}]{det\+\_\+data,  }\item[{bfield\+\_\+t}]{field\+\_\+data,  }\item[{vecmem\+::data\+::jagged\+\_\+vector\+\_\+view$<$ typename propagator\+\_\+t\+::intersection\+\_\+type $>$}]{nav\+\_\+candidates\+\_\+buffer,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::const\+\_\+view}}}]{in\+\_\+params\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ const \mbox{\hyperlink{structtraccc_1_1candidate__link}{candidate\+\_\+link}} $>$}]{links\+\_\+view,  }\item[{const unsigned int}]{step,  }\item[{const unsigned int \&}]{n\+\_\+in\+\_\+params,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{bound\+\_\+track\+\_\+parameters\+\_\+collection\+\_\+types\+::view}}}]{out\+\_\+params\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ unsigned int $>$}]{param\+\_\+to\+\_\+link\+\_\+view,  }\item[{vecmem\+::data\+::vector\+\_\+view$<$ typename \mbox{\hyperlink{structtraccc_1_1candidate__link_a43e4355337d1d689215e7a0c69b86636}{candidate\+\_\+link\+::link\+\_\+index\+\_\+type}} $>$}]{tips\+\_\+view,  }\item[{unsigned int \&}]{n\+\_\+out\+\_\+params }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function for propagating the kalman-\/updated tracks to the next surface

If a track finds a surface that contains measurements, its bound track parameter on the surface will be used for the next step. Otherwise, the link is added into the tip link container so that we can know which links in the link container are the final measurements of full tracks


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em cfg} & Track finding config object \\
\hline
\mbox{\texttt{ in}}  & {\em det\+\_\+data} & Detector view object \\
\hline
\mbox{\texttt{ in}}  & {\em nav\+\_\+candidates\+\_\+buffer} & Navgation buffer \\
\hline
\mbox{\texttt{ in}}  & {\em in\+\_\+params\+\_\+view} & Input parameters \\
\hline
\mbox{\texttt{ in}}  & {\em links\+\_\+view} & Link container for the current step \\
\hline
\mbox{\texttt{ in}}  & {\em step} & Step index \\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+in\+\_\+params} & The number of input parameters \\
\hline
\mbox{\texttt{ out}}  & {\em out\+\_\+params\+\_\+view} & Output parameters \\
\hline
\mbox{\texttt{ out}}  & {\em param\+\_\+to\+\_\+link\+\_\+view} & Container for param index -\/$>$ link index \\
\hline
\mbox{\texttt{ out}}  & {\em tips\+\_\+view} & Tip link container for the current step \\
\hline
\mbox{\texttt{ out}}  & {\em n\+\_\+out\+\_\+params} & The number of output parameters \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{26                                 \{}
\DoxyCodeLine{27 }
\DoxyCodeLine{28     \textcolor{keywordflow}{if} (globalIndex >= n\_in\_params) \{}
\DoxyCodeLine{29         \textcolor{keywordflow}{return};}
\DoxyCodeLine{30     \}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32     \textcolor{comment}{// Detector}}
\DoxyCodeLine{33     \textcolor{keyword}{typename} propagator\_t::detector\_type det(det\_data);}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// Navigation candidate buffer}}
\DoxyCodeLine{36     vecmem::jagged\_device\_vector<typename propagator\_t::intersection\_type>}
\DoxyCodeLine{37         nav\_candidates(nav\_candidates\_buffer);}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{comment}{// Input parameters}}
\DoxyCodeLine{40     bound\_track\_parameters\_collection\_types::const\_device in\_params(}
\DoxyCodeLine{41         in\_params\_view);}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{comment}{// Links}}
\DoxyCodeLine{44     vecmem::device\_vector<const candidate\_link> links(links\_view);}
\DoxyCodeLine{45 }
\DoxyCodeLine{46     \textcolor{comment}{// Out parameters}}
\DoxyCodeLine{47     bound\_track\_parameters\_collection\_types::device out\_params(out\_params\_view);}
\DoxyCodeLine{48 }
\DoxyCodeLine{49     \textcolor{comment}{// Param to Link ID}}
\DoxyCodeLine{50     vecmem::device\_vector<unsigned int> param\_to\_link(param\_to\_link\_view);}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{comment}{// tips}}
\DoxyCodeLine{53     vecmem::device\_vector<typename candidate\_link::link\_index\_type> tips(}
\DoxyCodeLine{54         tips\_view);}
\DoxyCodeLine{55 }
\DoxyCodeLine{56     \textcolor{comment}{// Input bound track parameter}}
\DoxyCodeLine{57     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_a49b1ec1e09c6b63a918d97428dd51f2e}{bound\_track\_parameters}} in\_par = in\_params.at(globalIndex);}
\DoxyCodeLine{58 }
\DoxyCodeLine{59     \textcolor{comment}{// Create propagator}}
\DoxyCodeLine{60     propagator\_t propagator(\{\}, \{\});}
\DoxyCodeLine{61 }
\DoxyCodeLine{62     \textcolor{comment}{// Create propagator state}}
\DoxyCodeLine{63     \textcolor{keyword}{typename} propagator\_t::state propagation(}
\DoxyCodeLine{64         in\_par, field\_data, det, std::move(nav\_candidates.at(globalIndex)));}
\DoxyCodeLine{65     propagation.\_stepping}
\DoxyCodeLine{66         .template set\_constraint<detray::step::constraint::e\_accuracy>(}
\DoxyCodeLine{67             cfg.constrained\_step\_size);}
\DoxyCodeLine{68 }
\DoxyCodeLine{69     \textcolor{comment}{// Actor state}}
\DoxyCodeLine{70     \textcolor{comment}{// @TODO: simplify the syntax here}}
\DoxyCodeLine{71     \textcolor{comment}{// @NOTE: Post material interaction might be required here}}
\DoxyCodeLine{72     \textcolor{keyword}{using} actor\_list\_type =}
\DoxyCodeLine{73         \textcolor{keyword}{typename} propagator\_t::actor\_chain\_type::actor\_list\_type;}
\DoxyCodeLine{74     \textcolor{keyword}{typename} detray::detail::tuple\_element<0, actor\_list\_type>::type::state}
\DoxyCodeLine{75         s0\{\};}
\DoxyCodeLine{76     \textcolor{keyword}{typename} detray::detail::tuple\_element<1, actor\_list\_type>::type::state}
\DoxyCodeLine{77         s1\{\};}
\DoxyCodeLine{78     \textcolor{keyword}{typename} detray::detail::tuple\_element<3, actor\_list\_type>::type::state}
\DoxyCodeLine{79         s3\{\};}
\DoxyCodeLine{80     \textcolor{keyword}{typename} detray::detail::tuple\_element<2, actor\_list\_type>::type::state s2\{}
\DoxyCodeLine{81         s3\};}
\DoxyCodeLine{82     \textcolor{keyword}{typename} detray::detail::tuple\_element<4, actor\_list\_type>::type::state s4\{}
\DoxyCodeLine{83         cfg.min\_step\_length\_for\_surface\_aborter\};}
\DoxyCodeLine{84 }
\DoxyCodeLine{85     \textcolor{comment}{// @TODO: Should be removed once detray is fixed to set the volume in the}}
\DoxyCodeLine{86     \textcolor{comment}{// constructor}}
\DoxyCodeLine{87     propagation.\_navigation.set\_volume(in\_par.surface\_link().volume());}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \textcolor{comment}{// Propagate to the next surface}}
\DoxyCodeLine{90     propagator.propagate\_sync(propagation, std::tie(s0, s1, s2, s3, s4));}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{comment}{// If a surface found, add the parameter for the next step}}
\DoxyCodeLine{93     \textcolor{keywordflow}{if} (s4.success) \{}
\DoxyCodeLine{94         vecmem::device\_atomic\_ref<unsigned int> num\_out\_params(n\_out\_params);}
\DoxyCodeLine{95         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} out\_param\_id = num\_out\_params.fetch\_add(1);}
\DoxyCodeLine{96 }
\DoxyCodeLine{97         out\_params[out\_param\_id] = propagation.\_stepping.\_bound\_params;}
\DoxyCodeLine{98 }
\DoxyCodeLine{99         param\_to\_link[out\_param\_id] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(globalIndex);}
\DoxyCodeLine{100     \}}
\DoxyCodeLine{101     \textcolor{comment}{// Unless the track found a surface, it is considered a tip}}
\DoxyCodeLine{102     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!s4.success \&\& step >= cfg.min\_track\_candidates\_per\_track -\/ 1) \{}
\DoxyCodeLine{103         tips.push\_back(\{step, globalIndex\});}
\DoxyCodeLine{104     \}}
\DoxyCodeLine{105 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacetraccc_1_1device_ab8368c09597104f9b3fecf98b4a1111d}\label{namespacetraccc_1_1device_ab8368c09597104f9b3fecf98b4a1111d}} 
\index{traccc::device@{traccc::device}!reduce\_problem\_cell@{reduce\_problem\_cell}}
\index{reduce\_problem\_cell@{reduce\_problem\_cell}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{reduce\_problem\_cell()}{reduce\_problem\_cell()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::reduce\+\_\+problem\+\_\+cell (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a2c17f74f33da865b1fb58c83e44ecb71}{cell\+\_\+collection\+\_\+types\+::const\+\_\+device}} \&}]{cells,  }\item[{const unsigned short}]{cid,  }\item[{const unsigned int}]{start,  }\item[{const unsigned int}]{end,  }\item[{unsigned char \&}]{adjc,  }\item[{unsigned short}]{adjv\mbox{[}8\mbox{]} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function for looking for adjacent cells. The cell ids will range from 0 to max\+\_\+cells\+\_\+per\+\_\+partition and the number of blocks will equal the number of partitions, hence checking all cells.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cells} & Collection of cells \\
\hline
\mbox{\texttt{ in}}  & {\em cid} & Current cell id \\
\hline
\mbox{\texttt{ in}}  & {\em start} & Current partition start point \\
\hline
\mbox{\texttt{ in}}  & {\em end} & Current partition end point \\
\hline
\mbox{\texttt{ out}}  & {\em ajc} & Number of adjacent cells \\
\hline
\mbox{\texttt{ out}}  & {\em ajv} & Indices of adjacent cells \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{29                             \{}
\DoxyCodeLine{30 }
\DoxyCodeLine{31     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} pos = cid + start;}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     \textcolor{comment}{// Check if this code can benefit from changing to structs of arrays, as the}}
\DoxyCodeLine{34     \textcolor{comment}{// recurring accesses to cell data in global memory is slow right now.}}
\DoxyCodeLine{35     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\_id}} c0 = cells[pos].channel0;}
\DoxyCodeLine{36     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_ac9cd1f64237a5da323f13740187b0cb8}{channel\_id}} c1 = cells[pos].channel1;}
\DoxyCodeLine{37     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mod\_id = cells[pos].module\_link;}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{comment}{/*}}
\DoxyCodeLine{40 \textcolor{comment}{     * First, we traverse the cells backwards, starting from the current}}
\DoxyCodeLine{41 \textcolor{comment}{     * cell and working back to the first, collecting adjacent cells}}
\DoxyCodeLine{42 \textcolor{comment}{     * along the way.}}
\DoxyCodeLine{43 \textcolor{comment}{     */}}
\DoxyCodeLine{44     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = pos -\/ 1; j < pos; -\/-\/j) \{}
\DoxyCodeLine{45         \textcolor{comment}{/*}}
\DoxyCodeLine{46 \textcolor{comment}{         * Since the data is sorted, we can assume that if we see a cell}}
\DoxyCodeLine{47 \textcolor{comment}{         * sufficiently far away in both directions, it becomes}}
\DoxyCodeLine{48 \textcolor{comment}{         * impossible for that cell to ever be adjacent to this one.}}
\DoxyCodeLine{49 \textcolor{comment}{         * This is a small optimisation.}}
\DoxyCodeLine{50 \textcolor{comment}{         */}}
\DoxyCodeLine{51         \textcolor{keywordflow}{if} (cells[j].channel1 + 1 < c1 || cells[j].module\_link != mod\_id) \{}
\DoxyCodeLine{52             \textcolor{keywordflow}{break};}
\DoxyCodeLine{53         \}}
\DoxyCodeLine{54 }
\DoxyCodeLine{55         \textcolor{comment}{/*}}
\DoxyCodeLine{56 \textcolor{comment}{         * If the cell examined is adjacent to the current cell, save it}}
\DoxyCodeLine{57 \textcolor{comment}{         * in the current cell's adjacency set.}}
\DoxyCodeLine{58 \textcolor{comment}{         */}}
\DoxyCodeLine{59         \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetraccc_1_1device_a32c38f509eef5398c63cc66721db1a83}{is\_adjacent}}(c0, c1, cells[j].channel0, cells[j].channel1)) \{}
\DoxyCodeLine{60             adjv[adjc++] = j -\/ start;}
\DoxyCodeLine{61         \}}
\DoxyCodeLine{62     \}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     \textcolor{comment}{/*}}
\DoxyCodeLine{65 \textcolor{comment}{     * Now we examine all the cells past the current one, using almost}}
\DoxyCodeLine{66 \textcolor{comment}{     * the same logic as in the backwards pass.}}
\DoxyCodeLine{67 \textcolor{comment}{     */}}
\DoxyCodeLine{68     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = pos + 1; j < end; ++j) \{}
\DoxyCodeLine{69         \textcolor{comment}{/*}}
\DoxyCodeLine{70 \textcolor{comment}{         * Note that this check now looks in the opposite direction! An}}
\DoxyCodeLine{71 \textcolor{comment}{         * important difference.}}
\DoxyCodeLine{72 \textcolor{comment}{         */}}
\DoxyCodeLine{73         \textcolor{keywordflow}{if} (cells[j].channel1 > c1 + 1 || cells[j].module\_link != mod\_id) \{}
\DoxyCodeLine{74             \textcolor{keywordflow}{break};}
\DoxyCodeLine{75         \}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77         \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespacetraccc_1_1device_a32c38f509eef5398c63cc66721db1a83}{is\_adjacent}}(c0, c1, cells[j].channel0, cells[j].channel1)) \{}
\DoxyCodeLine{78             adjv[adjc++] = j -\/ start;}
\DoxyCodeLine{79         \}}
\DoxyCodeLine{80     \}}
\DoxyCodeLine{81 \}}

\end{DoxyCode}


References is\+\_\+adjacent().



Referenced by ccl\+\_\+kernel().

\mbox{\Hypertarget{namespacetraccc_1_1device_a0aea434e4a014b6fd621ebd0d7100fbe}\label{namespacetraccc_1_1device_a0aea434e4a014b6fd621ebd0d7100fbe}} 
\index{traccc::device@{traccc::device}!reduce\_triplet\_counts@{reduce\_triplet\_counts}}
\index{reduce\_triplet\_counts@{reduce\_triplet\_counts}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{reduce\_triplet\_counts()}{reduce\_triplet\_counts()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::reduce\+\_\+triplet\+\_\+counts (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{doublet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{dc\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::view}}}]{sp\+M\+\_\+tc\+\_\+view,  }\item[{unsigned int \&}]{num\+\_\+triplets }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for performing a reduction on the triplet counters

The {\ttfamily count\+\_\+triplets} function will only count the number of triplets per each middle spacepoint independently. Thus, we need to perform a sum over all middle spacepoints, as well as correctly claim the positions in which the triplets will be filled in {\ttfamily find\+:triplets} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em dc\+\_\+view} & Collection of doublet counters \\
\hline
\mbox{\texttt{ in,out}}  & {\em sp\+M\+\_\+tc\+\_\+view} & Collection of triplet counters per middle spacepoint \\
\hline
\mbox{\texttt{ out}}  & {\em num\+\_\+triplets} & The total number of triplets \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{20                                 \{}
\DoxyCodeLine{21 }
\DoxyCodeLine{22     \textcolor{comment}{// Get device copy of input parameters}}
\DoxyCodeLine{23     triplet\_counter\_spM\_collection\_types::device spM\_counts(spM\_tc\_view);}
\DoxyCodeLine{24     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{25     \textcolor{keywordflow}{if} (globalIndex >= spM\_counts.size()) \{}
\DoxyCodeLine{26         \textcolor{keywordflow}{return};}
\DoxyCodeLine{27     \}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{keyword}{const} doublet\_counter\_collection\_types::const\_device doublet\_counts(}
\DoxyCodeLine{30         dc\_view);}
\DoxyCodeLine{31 }
\DoxyCodeLine{32     \textcolor{comment}{// This should only ever be called with two collections of equal size}}
\DoxyCodeLine{33     assert(doublet\_counts.size() == spM\_counts.size());}
\DoxyCodeLine{34 }
\DoxyCodeLine{35     \textcolor{comment}{// Get triplet counter for this middle spacepoint}}
\DoxyCodeLine{36     triplet\_counter\_spM\& this\_spM\_counter = spM\_counts.at(globalIndex);}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{39     \textcolor{keywordflow}{if} (this\_spM\_counter.m\_nTriplets == 0) \{}
\DoxyCodeLine{40         \textcolor{keywordflow}{return};}
\DoxyCodeLine{41     \}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{comment}{// Fill the middle spacepoint information of the spM triplet counter}}
\DoxyCodeLine{44     this\_spM\_counter.spM = doublet\_counts.at(globalIndex).m\_spM;}
\DoxyCodeLine{45 }
\DoxyCodeLine{46     \textcolor{comment}{// Increment total number of triplets and claim position for this middle}}
\DoxyCodeLine{47     \textcolor{comment}{// spacepoint's triplets}}
\DoxyCodeLine{48     vecmem::device\_atomic\_ref<unsigned int> nTriplets(num\_triplets);}
\DoxyCodeLine{49     this\_spM\_counter.posTriplets =}
\DoxyCodeLine{50         nTriplets.fetch\_add(this\_spM\_counter.m\_nTriplets);}
\DoxyCodeLine{51 \}}

\end{DoxyCode}


References traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::m\+\_\+n\+Triplets, traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::pos\+Triplets, and traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::spM.

\mbox{\Hypertarget{namespacetraccc_1_1device_ada5aab00f224f7d53c4b717042d099c4}\label{namespacetraccc_1_1device_ada5aab00f224f7d53c4b717042d099c4}} 
\index{traccc::device@{traccc::device}!select\_seeds@{select\_seeds}}
\index{select\_seeds@{select\_seeds}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{select\_seeds()}{select\_seeds()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::select\+\_\+seeds (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfilter__config}{seedfilter\+\_\+config}} \&}]{filter\+\_\+config,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{spacepoint\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{spacepoints\+\_\+view,  }\item[{const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&}]{internal\+\_\+sp\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{sp\+M\+\_\+tc\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{tc\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{device\+\_\+triplet\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{triplet\+\_\+view,  }\item[{\mbox{\hyperlink{structtraccc_1_1triplet}{triplet}} $\ast$}]{data,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{seed\+\_\+collection\+\_\+types\+::view}}}]{seed\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for selecting good triplets to be recorded into seed collection


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em filter\+\_\+config} & Seed filter config \\
\hline
\mbox{\texttt{ in}}  & {\em spacepoints\+\_\+view} & Collection of spacepoints \\
\hline
\mbox{\texttt{ in}}  & {\em internal\+\_\+sp\+\_\+view} & The spacepoint grid \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+M\+\_\+tc\+\_\+view} & Collection with the number of triplets per spM \\
\hline
\mbox{\texttt{ in}}  & {\em triplet\+\_\+view} & Collection of triplets \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Array for temporary storage of triplets for comparison \\
\hline
\mbox{\texttt{ out}}  & {\em seed\+\_\+view} & Collection of seeds \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{64                                                         \{}
\DoxyCodeLine{65 }
\DoxyCodeLine{66     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{67     \textcolor{keyword}{const} triplet\_counter\_spM\_collection\_types::const\_device triplet\_counts\_spM(}
\DoxyCodeLine{68         spM\_tc\_view);}
\DoxyCodeLine{69     \textcolor{keywordflow}{if} (globalIndex >= triplet\_counts\_spM.size()) \{}
\DoxyCodeLine{70         \textcolor{keywordflow}{return};}
\DoxyCodeLine{71     \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73     \textcolor{comment}{// Set up the device containers}}
\DoxyCodeLine{74     \textcolor{keyword}{const} triplet\_counter\_collection\_types::const\_device triplet\_counts(}
\DoxyCodeLine{75         tc\_view);}
\DoxyCodeLine{76     \textcolor{keyword}{const} spacepoint\_collection\_types::const\_device spacepoints\_device(}
\DoxyCodeLine{77         spacepoints\_view);}
\DoxyCodeLine{78     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_afdad33573f6399c7e2671b6968dfc29c}{const\_sp\_grid\_device}} internal\_sp\_device(internal\_sp\_view);}
\DoxyCodeLine{79 }
\DoxyCodeLine{80     device\_triplet\_collection\_types::const\_device triplets(triplet\_view);}
\DoxyCodeLine{81     seed\_collection\_types::device seeds\_device(seed\_view);}
\DoxyCodeLine{82 }
\DoxyCodeLine{83     \textcolor{comment}{// Current work item = middle spacepoint}}
\DoxyCodeLine{84     \textcolor{keyword}{const} triplet\_counter\_spM spM\_counter = triplet\_counts\_spM.at(globalIndex);}
\DoxyCodeLine{85     \textcolor{keyword}{const} sp\_location spM\_loc = spM\_counter.spM;}
\DoxyCodeLine{86     \textcolor{keyword}{const} internal\_spacepoint<spacepoint> spM =}
\DoxyCodeLine{87         internal\_sp\_device.bin(spM\_loc.bin\_idx)[spM\_loc.sp\_idx];}
\DoxyCodeLine{88 }
\DoxyCodeLine{89     \textcolor{comment}{// Number of triplets added for this spM}}
\DoxyCodeLine{90     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_triplets\_per\_spM = 0;}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} end\_triplets\_spM =}
\DoxyCodeLine{93         spM\_counter.posTriplets + spM\_counter.m\_nTriplets;}
\DoxyCodeLine{94     \textcolor{comment}{// iterate over the triplets in the bin}}
\DoxyCodeLine{95     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = spM\_counter.posTriplets; i < end\_triplets\_spM; ++i) \{}
\DoxyCodeLine{96         device\_triplet aTriplet = triplets[i];}
\DoxyCodeLine{97 }
\DoxyCodeLine{98         \textcolor{comment}{// spacepoints bottom and top for this triplet}}
\DoxyCodeLine{99         \textcolor{keyword}{const} sp\_location spB\_loc =}
\DoxyCodeLine{100             triplet\_counts.at(aTriplet.counter\_link).spB;}
\DoxyCodeLine{101         \textcolor{keyword}{const} sp\_location spT\_loc = aTriplet.spT;}
\DoxyCodeLine{102         \textcolor{keyword}{const} internal\_spacepoint<spacepoint> spB =}
\DoxyCodeLine{103             internal\_sp\_device.bin(spB\_loc.bin\_idx)[spB\_loc.sp\_idx];}
\DoxyCodeLine{104         \textcolor{keyword}{const} internal\_spacepoint<spacepoint> spT =}
\DoxyCodeLine{105             internal\_sp\_device.bin(spT\_loc.bin\_idx)[spT\_loc.sp\_idx];}
\DoxyCodeLine{106 }
\DoxyCodeLine{107         \textcolor{comment}{// update weight of triplet}}
\DoxyCodeLine{108         seed\_selecting\_helper::seed\_weight(filter\_config, spM, spB, spT,}
\DoxyCodeLine{109                                            aTriplet.weight);}
\DoxyCodeLine{110 }
\DoxyCodeLine{111         \textcolor{comment}{// check if it is a good triplet}}
\DoxyCodeLine{112         \textcolor{keywordflow}{if} (!seed\_selecting\_helper::single\_seed\_cut(filter\_config, spM, spB,}
\DoxyCodeLine{113                                                     spT, aTriplet.weight)) \{}
\DoxyCodeLine{114             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{115         \}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117         \textcolor{comment}{// if the number of good triplets is larger than the threshold,}}
\DoxyCodeLine{118         \textcolor{comment}{// the triplet with the lowest weight is removed}}
\DoxyCodeLine{119         \textcolor{keywordflow}{if} (n\_triplets\_per\_spM >= filter\_config.max\_triplets\_per\_spM) \{}
\DoxyCodeLine{120 }
\DoxyCodeLine{121             \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_index =}
\DoxyCodeLine{122                 \mbox{\hyperlink{namespacetraccc_1_1device_1_1details_a8f4ac52a914ad8541e79747fe5031ea9}{details::min\_elem}}(data, 0, filter\_config.max\_triplets\_per\_spM,}
\DoxyCodeLine{123                                   [](\textcolor{keyword}{const} triplet lhs, \textcolor{keyword}{const} triplet rhs) \{}
\DoxyCodeLine{124                                       return lhs.weight > rhs.weight;}
\DoxyCodeLine{125                                   \});}
\DoxyCodeLine{126 }
\DoxyCodeLine{127             \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}}\& min\_weight = data[min\_index].weight;}
\DoxyCodeLine{128 }
\DoxyCodeLine{129             \textcolor{keywordflow}{if} (aTriplet.weight > min\_weight) \{}
\DoxyCodeLine{130                 data[min\_index] = \{spB\_loc,         spM\_loc,}
\DoxyCodeLine{131                                    spT\_loc,         aTriplet.curvature,}
\DoxyCodeLine{132                                    aTriplet.weight, aTriplet.z\_vertex\};}
\DoxyCodeLine{133             \}}
\DoxyCodeLine{134         \}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136         \textcolor{comment}{// if the number of good triplets is below the threshold, add}}
\DoxyCodeLine{137         \textcolor{comment}{// the current triplet to the array}}
\DoxyCodeLine{138         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n\_triplets\_per\_spM < filter\_config.max\_triplets\_per\_spM) \{}
\DoxyCodeLine{139             data[n\_triplets\_per\_spM] = \{spB\_loc,         spM\_loc,}
\DoxyCodeLine{140                                         spT\_loc,         aTriplet.curvature,}
\DoxyCodeLine{141                                         aTriplet.weight, aTriplet.z\_vertex\};}
\DoxyCodeLine{142             n\_triplets\_per\_spM++;}
\DoxyCodeLine{143         \}}
\DoxyCodeLine{144     \}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146     \textcolor{comment}{// sort the triplets per spM}}
\DoxyCodeLine{147     \mbox{\hyperlink{namespacetraccc_1_1device_1_1details_a78a788b16fc4939f7c8ad1db674160d7}{details::insertionSort}}(}
\DoxyCodeLine{148         data, 0, n\_triplets\_per\_spM, [\&](triplet\& lhs, triplet\& rhs) \{}
\DoxyCodeLine{149             \textcolor{keywordflow}{if} (lhs.weight != rhs.weight) \{}
\DoxyCodeLine{150                 return lhs.weight > rhs.weight;}
\DoxyCodeLine{151             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{152 }
\DoxyCodeLine{153                 scalar seed1\_sum = 0;}
\DoxyCodeLine{154                 scalar seed2\_sum = 0;}
\DoxyCodeLine{155 }
\DoxyCodeLine{156                 const internal\_spacepoint<spacepoint>\& ispB1 =}
\DoxyCodeLine{157                     internal\_sp\_device.bin(lhs.sp1.bin\_idx)[lhs.sp1.sp\_idx];}
\DoxyCodeLine{158                 const internal\_spacepoint<spacepoint>\& ispT1 =}
\DoxyCodeLine{159                     internal\_sp\_device.bin(lhs.sp3.bin\_idx)[lhs.sp3.sp\_idx];}
\DoxyCodeLine{160                 const internal\_spacepoint<spacepoint>\& ispB2 =}
\DoxyCodeLine{161                     internal\_sp\_device.bin(rhs.sp1.bin\_idx)[rhs.sp1.sp\_idx];}
\DoxyCodeLine{162                 const internal\_spacepoint<spacepoint>\& ispT2 =}
\DoxyCodeLine{163                     internal\_sp\_device.bin(rhs.sp3.bin\_idx)[rhs.sp3.sp\_idx];}
\DoxyCodeLine{164 }
\DoxyCodeLine{165                 const spacepoint\& spB1 = spacepoints\_device.at(ispB1.m\_link);}
\DoxyCodeLine{166                 const spacepoint\& spT1 = spacepoints\_device.at(ispT1.m\_link);}
\DoxyCodeLine{167                 const spacepoint\& spB2 = spacepoints\_device.at(ispB2.m\_link);}
\DoxyCodeLine{168                 const spacepoint\& spT2 = spacepoints\_device.at(ispT2.m\_link);}
\DoxyCodeLine{169 }
\DoxyCodeLine{170                 constexpr scalar exp = 2;}
\DoxyCodeLine{171                 seed1\_sum += std::pow(spB1.y(), exp) + std::pow(spB1.z(), exp);}
\DoxyCodeLine{172                 seed1\_sum += std::pow(spT1.y(), exp) + std::pow(spT1.z(), exp);}
\DoxyCodeLine{173                 seed2\_sum += std::pow(spB2.y(), exp) + std::pow(spB2.z(), exp);}
\DoxyCodeLine{174                 seed2\_sum += std::pow(spT2.y(), exp) + std::pow(spT2.z(), exp);}
\DoxyCodeLine{175 }
\DoxyCodeLine{176                 return seed1\_sum > seed2\_sum;}
\DoxyCodeLine{177             \}}
\DoxyCodeLine{178         \});}
\DoxyCodeLine{179 }
\DoxyCodeLine{180     \textcolor{comment}{// the number of good seed per compatible middle spacepoint}}
\DoxyCodeLine{181     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} n\_seeds\_per\_spM = 0;}
\DoxyCodeLine{182 }
\DoxyCodeLine{183     \textcolor{comment}{// iterate over the good triplets for final selection of seeds}}
\DoxyCodeLine{184     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < n\_triplets\_per\_spM; ++i) \{}
\DoxyCodeLine{185         \textcolor{keyword}{const} triplet\& aTriplet = data[i];}
\DoxyCodeLine{186         \textcolor{keyword}{const} sp\_location\& spB\_loc = aTriplet.sp1;}
\DoxyCodeLine{187         \textcolor{keyword}{const} sp\_location\& spT\_loc = aTriplet.sp3;}
\DoxyCodeLine{188         \textcolor{keyword}{const} internal\_spacepoint<spacepoint>\& spB =}
\DoxyCodeLine{189             internal\_sp\_device.bin(spB\_loc.bin\_idx)[spB\_loc.sp\_idx];}
\DoxyCodeLine{190         \textcolor{keyword}{const} internal\_spacepoint<spacepoint>\& spT =}
\DoxyCodeLine{191             internal\_sp\_device.bin(spT\_loc.bin\_idx)[spT\_loc.sp\_idx];}
\DoxyCodeLine{192 }
\DoxyCodeLine{193         \textcolor{comment}{// if the number of seeds reaches the threshold, break}}
\DoxyCodeLine{194         \textcolor{keywordflow}{if} (n\_seeds\_per\_spM >= filter\_config.maxSeedsPerSpM + 1) \{}
\DoxyCodeLine{195             \textcolor{keywordflow}{break};}
\DoxyCodeLine{196         \}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198         seed aSeed(\{spB.m\_link, spM.m\_link, spT.m\_link, aTriplet.weight,}
\DoxyCodeLine{199                     aTriplet.z\_vertex\});}
\DoxyCodeLine{200 }
\DoxyCodeLine{201         \textcolor{comment}{// check if it is a good triplet}}
\DoxyCodeLine{202         \textcolor{keywordflow}{if} (seed\_selecting\_helper::cut\_per\_middle\_sp(}
\DoxyCodeLine{203                 filter\_config, spacepoints\_device, aSeed, aTriplet.weight) ||}
\DoxyCodeLine{204             n\_seeds\_per\_spM == 0) \{}
\DoxyCodeLine{205 }
\DoxyCodeLine{206             n\_seeds\_per\_spM++;}
\DoxyCodeLine{207 }
\DoxyCodeLine{208             seeds\_device.push\_back(aSeed);}
\DoxyCodeLine{209         \}}
\DoxyCodeLine{210     \}}
\DoxyCodeLine{211 \}}

\end{DoxyCode}


References traccc\+::sp\+\_\+location\+::bin\+\_\+idx, traccc\+::device\+::device\+\_\+triplet\+::counter\+\_\+link, traccc\+::device\+::device\+\_\+triplet\+::curvature, traccc\+::seed\+\_\+selecting\+\_\+helper\+::cut\+\_\+per\+\_\+middle\+\_\+sp(), traccc\+::device\+::details\+::insertion\+Sort(), traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::m\+\_\+link, traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::m\+\_\+n\+Triplets, traccc\+::seedfilter\+\_\+config\+::max\+\_\+triplets\+\_\+per\+\_\+spM, traccc\+::seedfilter\+\_\+config\+::max\+Seeds\+Per\+SpM, traccc\+::device\+::details\+::min\+\_\+elem(), traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::pos\+Triplets, traccc\+::seed\+\_\+selecting\+\_\+helper\+::seed\+\_\+weight(), traccc\+::seed\+\_\+selecting\+\_\+helper\+::single\+\_\+seed\+\_\+cut(), traccc\+::triplet\+::sp1, traccc\+::triplet\+::sp3, traccc\+::sp\+\_\+location\+::sp\+\_\+idx, traccc\+::device\+::triplet\+\_\+counter\+\_\+sp\+M\+::spM, traccc\+::device\+::device\+\_\+triplet\+::spT, traccc\+::device\+::device\+\_\+triplet\+::weight, traccc\+::triplet\+::weight, traccc\+::device\+::device\+\_\+triplet\+::z\+\_\+vertex, and traccc\+::triplet\+::z\+\_\+vertex.

\mbox{\Hypertarget{namespacetraccc_1_1device_ab5df4029912b7c1cd4d2186bf9434a1d}\label{namespacetraccc_1_1device_ab5df4029912b7c1cd4d2186bf9434a1d}} 
\index{traccc::device@{traccc::device}!update\_triplet\_weights@{update\_triplet\_weights}}
\index{update\_triplet\_weights@{update\_triplet\_weights}!traccc::device@{traccc::device}}
\doxysubsubsection{\texorpdfstring{update\_triplet\_weights()}{update\_triplet\_weights()}}
{\footnotesize\ttfamily \mbox{\hyperlink{qualifiers_8hpp_a883f657259ab2dcc9d7b3ffd6165541a}{T\+R\+A\+C\+C\+C\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+CE}} void traccc\+::device\+::update\+\_\+triplet\+\_\+weights (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{global\+Index,  }\item[{const \mbox{\hyperlink{structtraccc_1_1seedfilter__config}{seedfilter\+\_\+config}} \&}]{filter\+\_\+config,  }\item[{const \mbox{\hyperlink{namespacetraccc_a9fd4dd5935c4a4b0ad8659bbf05c913c}{sp\+\_\+grid\+\_\+const\+\_\+view}} \&}]{sp\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+sp\+M\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{sp\+M\+\_\+tc\+\_\+view,  }\item[{const \mbox{\hyperlink{structtraccc_1_1collection__types_a6ef00cb04070f8f7954499bdaa71ddf0}{triplet\+\_\+counter\+\_\+collection\+\_\+types\+::const\+\_\+view}} \&}]{tc\+\_\+view,  }\item[{\mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} $\ast$}]{data,  }\item[{\mbox{\hyperlink{structtraccc_1_1collection__types_a81f48fe7d1fbbd487c3dbdad322b1142}{device\+\_\+triplet\+\_\+collection\+\_\+types\+::view}}}]{triplet\+\_\+view }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Function used for updating the triplets\textquotesingle{} weights


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em global\+Index} & The index of the current thread \\
\hline
\mbox{\texttt{ in}}  & {\em filter\+\_\+config} & Seedfilter configuration \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+\_\+view} & The spacepoint grid \\
\hline
\mbox{\texttt{ in}}  & {\em sp\+M\+\_\+tc\+\_\+view} & Collection of triplet counts per spM \\
\hline
\mbox{\texttt{ in}}  & {\em tc\+\_\+view} & Collection of triplet counts per mid\+Bot doublet \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Array for temporary storage of quality parameters for comparison of triplets \\
\hline
\mbox{\texttt{ in,out}}  & {\em triplet\+\_\+view} & Collection of triplets \\
\hline
\end{DoxyParams}

\begin{DoxyCode}{0}
\DoxyCodeLine{21                                                       \{}
\DoxyCodeLine{22 }
\DoxyCodeLine{23     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{24     device\_triplet\_collection\_types::device triplets(triplet\_view);}
\DoxyCodeLine{25     \textcolor{keywordflow}{if} (globalIndex >= triplets.size()) \{}
\DoxyCodeLine{26         \textcolor{keywordflow}{return};}
\DoxyCodeLine{27     \}}
\DoxyCodeLine{28 }
\DoxyCodeLine{29     \textcolor{comment}{// Set up the device containers}}
\DoxyCodeLine{30     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_afdad33573f6399c7e2671b6968dfc29c}{const\_sp\_grid\_device}} \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}(sp\_view);}
\DoxyCodeLine{31     \textcolor{keyword}{const} triplet\_counter\_spM\_collection\_types::const\_device triplet\_counts\_spM(}
\DoxyCodeLine{32         spM\_tc\_view);}
\DoxyCodeLine{33     \textcolor{keyword}{const} triplet\_counter\_collection\_types::const\_device triplet\_counts(}
\DoxyCodeLine{34         tc\_view);}
\DoxyCodeLine{35 }
\DoxyCodeLine{36     \textcolor{comment}{// Current work item}}
\DoxyCodeLine{37     device\_triplet this\_triplet = triplets[globalIndex];}
\DoxyCodeLine{38 }
\DoxyCodeLine{39     \textcolor{keyword}{const} sp\_location\& spT\_idx = this\_triplet.spT;}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} current\_spT =}
\DoxyCodeLine{42         \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(spT\_idx.bin\_idx)[spT\_idx.sp\_idx];}
\DoxyCodeLine{43 }
\DoxyCodeLine{44     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} currentTop\_r = current\_spT.\mbox{\hyperlink{structtraccc_1_1internal__spacepoint_a061cdd2ac8f79dd73d7bb5eef846daa6}{radius}}();}
\DoxyCodeLine{45 }
\DoxyCodeLine{46     \textcolor{comment}{// if two compatible seeds with high distance in r are found, compatible}}
\DoxyCodeLine{47     \textcolor{comment}{// seeds span 5 layers}}
\DoxyCodeLine{48     \textcolor{comment}{// -\/> very good seed}}
\DoxyCodeLine{49     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} lowerLimitCurv =}
\DoxyCodeLine{50         this\_triplet.curvature -\/ filter\_config.deltaInvHelixDiameter;}
\DoxyCodeLine{51     \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} upperLimitCurv =}
\DoxyCodeLine{52         this\_triplet.curvature + filter\_config.deltaInvHelixDiameter;}
\DoxyCodeLine{53     std::size\_t num\_compat\_seedR = 0;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{keyword}{const} triplet\_counter mb\_count =}
\DoxyCodeLine{56         triplet\_counts.at(this\_triplet.counter\_link);}
\DoxyCodeLine{57 }
\DoxyCodeLine{58     \textcolor{comment}{// Check if anything needs to be done.}}
\DoxyCodeLine{59     \textcolor{keywordflow}{if} (mb\_count.m\_nTriplets <= 1) \{}
\DoxyCodeLine{60         \textcolor{keywordflow}{return};}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     \textcolor{comment}{// Get the position of the triplets which share this sabe midBottom doublet}}
\DoxyCodeLine{64     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} triplets\_mb\_begin =}
\DoxyCodeLine{65         mb\_count.posTriplets +}
\DoxyCodeLine{66         triplet\_counts\_spM.at(mb\_count.spM\_counter\_link).posTriplets;}
\DoxyCodeLine{67     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} triplets\_mb\_end =}
\DoxyCodeLine{68         triplets\_mb\_begin + mb\_count.m\_nTriplets;}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     \textcolor{comment}{// iterate over triplets}}
\DoxyCodeLine{71     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = triplets\_mb\_begin; i < triplets\_mb\_end; ++i) \{}
\DoxyCodeLine{72         \textcolor{comment}{// skip same triplet}}
\DoxyCodeLine{73         \textcolor{keywordflow}{if} (i == globalIndex) \{}
\DoxyCodeLine{74             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{75         \}}
\DoxyCodeLine{76 }
\DoxyCodeLine{77         \textcolor{keyword}{const} device\_triplet other\_triplet = triplets[i];}
\DoxyCodeLine{78         \textcolor{keyword}{const} sp\_location other\_spT\_idx = other\_triplet.spT;}
\DoxyCodeLine{79         \textcolor{keyword}{const} \mbox{\hyperlink{structtraccc_1_1internal__spacepoint}{traccc::internal\_spacepoint<traccc::spacepoint>}} other\_spT =}
\DoxyCodeLine{80             \mbox{\hyperlink{namespacetraccc_a238ca82836cc5cff0a7c1026ea0530e0}{sp\_grid}}.bin(other\_spT\_idx.bin\_idx)[other\_spT\_idx.sp\_idx];}
\DoxyCodeLine{81 }
\DoxyCodeLine{82         \textcolor{comment}{// compared top SP should have at least deltaRMin distance}}
\DoxyCodeLine{83         \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} otherTop\_r = other\_spT.\mbox{\hyperlink{structtraccc_1_1internal__spacepoint_a061cdd2ac8f79dd73d7bb5eef846daa6}{radius}}();}
\DoxyCodeLine{84         \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} deltaR = currentTop\_r -\/ otherTop\_r;}
\DoxyCodeLine{85         \textcolor{keywordflow}{if} (std::abs(deltaR) < filter\_config.deltaRMin) \{}
\DoxyCodeLine{86             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{87         \}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89         \textcolor{comment}{// curvature difference within limits?}}
\DoxyCodeLine{90         \textcolor{comment}{// TODO: how much slower than sorting all vectors by curvature}}
\DoxyCodeLine{91         \textcolor{comment}{// and breaking out of loop? i.e. is vector size large (e.g. in}}
\DoxyCodeLine{92         \textcolor{comment}{// jets?)}}
\DoxyCodeLine{93         \textcolor{keywordflow}{if} (other\_triplet.curvature < lowerLimitCurv) \{}
\DoxyCodeLine{94             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{95         \}}
\DoxyCodeLine{96         \textcolor{keywordflow}{if} (other\_triplet.curvature > upperLimitCurv) \{}
\DoxyCodeLine{97             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{98         \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100         \textcolor{keywordtype}{bool} newCompSeed = \textcolor{keyword}{true};}
\DoxyCodeLine{101 }
\DoxyCodeLine{102         \textcolor{keywordflow}{for} (std::size\_t i\_s = 0; i\_s < num\_compat\_seedR; ++i\_s) \{}
\DoxyCodeLine{103             \textcolor{keyword}{const} \mbox{\hyperlink{namespacetraccc_aab82ddc5db54d9ad84b1215320482993}{scalar}} previousDiameter = data[i\_s];}
\DoxyCodeLine{104 }
\DoxyCodeLine{105             \textcolor{comment}{// original ATLAS code uses higher min distance for 2nd found}}
\DoxyCodeLine{106             \textcolor{comment}{// compatible seed (20mm instead of 5mm) add new compatible seed}}
\DoxyCodeLine{107             \textcolor{comment}{// only if distance larger than rmin to all other compatible}}
\DoxyCodeLine{108             \textcolor{comment}{// seeds}}
\DoxyCodeLine{109             \textcolor{keywordflow}{if} (std::abs(previousDiameter -\/ otherTop\_r) <}
\DoxyCodeLine{110                 filter\_config.deltaRMin) \{}
\DoxyCodeLine{111                 newCompSeed = \textcolor{keyword}{false};}
\DoxyCodeLine{112                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{113             \}}
\DoxyCodeLine{114         \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116         \textcolor{keywordflow}{if} (newCompSeed) \{}
\DoxyCodeLine{117             data[num\_compat\_seedR] = otherTop\_r;}
\DoxyCodeLine{118             this\_triplet.weight += filter\_config.compatSeedWeight;}
\DoxyCodeLine{119             num\_compat\_seedR++;}
\DoxyCodeLine{120         \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122         \textcolor{keywordflow}{if} (num\_compat\_seedR >= filter\_config.compatSeedLimit) \{}
\DoxyCodeLine{123             \textcolor{keywordflow}{break};}
\DoxyCodeLine{124         \}}
\DoxyCodeLine{125     \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     triplets[globalIndex].weight = this\_triplet.weight;}
\DoxyCodeLine{128 \}}

\end{DoxyCode}


References traccc\+::sp\+\_\+location\+::bin\+\_\+idx, traccc\+::seedfilter\+\_\+config\+::compat\+Seed\+Limit, traccc\+::seedfilter\+\_\+config\+::compat\+Seed\+Weight, traccc\+::device\+::device\+\_\+triplet\+::counter\+\_\+link, traccc\+::device\+::device\+\_\+triplet\+::curvature, traccc\+::seedfilter\+\_\+config\+::delta\+Inv\+Helix\+Diameter, traccc\+::seedfilter\+\_\+config\+::delta\+R\+Min, traccc\+::device\+::triplet\+\_\+counter\+::m\+\_\+n\+Triplets, traccc\+::device\+::triplet\+\_\+counter\+::pos\+Triplets, traccc\+::internal\+\_\+spacepoint$<$ spacepoint\+\_\+t $>$\+::radius(), traccc\+::sp\+\_\+location\+::sp\+\_\+idx, traccc\+::device\+::triplet\+\_\+counter\+::sp\+M\+\_\+counter\+\_\+link, traccc\+::device\+::device\+\_\+triplet\+::spT, and traccc\+::device\+::device\+\_\+triplet\+::weight.

