\hypertarget{namespacetraccc_1_1cuda}{}\doxysection{traccc\+::cuda Namespace Reference}
\label{namespacetraccc_1_1cuda}\index{traccc::cuda@{traccc::cuda}}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespacetraccc_1_1cuda_1_1details}{details}}
\item 
 \mbox{\hyperlink{namespacetraccc_1_1cuda_1_1experimental}{experimental}}
\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structtraccc_1_1cuda_1_1barrier}{barrier}}
\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1clusterization__algorithm}{clusterization\+\_\+algorithm}}
\item 
struct \mbox{\hyperlink{structtraccc_1_1cuda_1_1component__connection}{component\+\_\+connection}}
\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1finding__algorithm}{finding\+\_\+algorithm}}
\begin{DoxyCompactList}\small\item\em Track Finding algorithm for a set of tracks. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1fitting__algorithm}{fitting\+\_\+algorithm}}
\begin{DoxyCompactList}\small\item\em Fitting algorithm for a set of tracks. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1full__chain__algorithm}{full\+\_\+chain\+\_\+algorithm}}
\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1seed__finding}{seed\+\_\+finding}}
\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1seeding__algorithm}{seeding\+\_\+algorithm}}
\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1spacepoint__binning}{spacepoint\+\_\+binning}}
\item 
class \mbox{\hyperlink{classtraccc_1_1cuda_1_1stream}{stream}}
\item 
struct \mbox{\hyperlink{structtraccc_1_1cuda_1_1track__params__estimation}{track\+\_\+params\+\_\+estimation}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
vecmem\+::data\+::vector\+\_\+buffer$<$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{device\+::prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$ \mbox{\hyperlink{namespacetraccc_1_1cuda_a923330559ca3d86d9c3888d80c5860ab}{make\+\_\+prefix\+\_\+sum\+\_\+buff}} (const std\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{device\+::prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&sizes, vecmem\+::copy \&copy, const \mbox{\hyperlink{structtraccc_1_1memory__resource}{traccc\+::memory\+\_\+resource}} \&mr)
\item 
vecmem\+::data\+::vector\+\_\+buffer$<$ \mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{device\+::prefix\+\_\+sum\+\_\+element\+\_\+t}} $>$ \mbox{\hyperlink{namespacetraccc_1_1cuda_aaf5709adc5f8f4e3ee52b7eef97a87f8}{make\+\_\+prefix\+\_\+sum\+\_\+buff}} (const std\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{device\+::prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&sizes, vecmem\+::copy \&copy, const \mbox{\hyperlink{structtraccc_1_1memory__resource}{traccc\+::memory\+\_\+resource}} \&mr, const \mbox{\hyperlink{classtraccc_1_1cuda_1_1stream}{stream}} \&str)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2022 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0

T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2023 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0

T\+R\+A\+C\+CC library, part of the A\+C\+TS project (R\&D line)

(c) 2021-\/2023 C\+E\+RN for the benefit of the A\+C\+TS project

Mozilla Public License Version 2.\+0 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacetraccc_1_1cuda_a923330559ca3d86d9c3888d80c5860ab}\label{namespacetraccc_1_1cuda_a923330559ca3d86d9c3888d80c5860ab}} 
\index{traccc::cuda@{traccc::cuda}!make\_prefix\_sum\_buff@{make\_prefix\_sum\_buff}}
\index{make\_prefix\_sum\_buff@{make\_prefix\_sum\_buff}!traccc::cuda@{traccc::cuda}}
\doxysubsubsection{\texorpdfstring{make\_prefix\_sum\_buff()}{make\_prefix\_sum\_buff()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily vecmem\+::data\+::vector\+\_\+buffer$<$\mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{device\+::prefix\+\_\+sum\+\_\+element\+\_\+t}}$>$ traccc\+::cuda\+::make\+\_\+prefix\+\_\+sum\+\_\+buff (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{device\+::prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&}]{sizes,  }\item[{vecmem\+::copy \&}]{copy,  }\item[{const \mbox{\hyperlink{structtraccc_1_1memory__resource}{traccc\+::memory\+\_\+resource}} \&}]{mr }\end{DoxyParamCaption})}

Function that returns vector of prefix\+\_\+sum\+\_\+element\+\_\+t for accessing a jagged vector\textquotesingle{}s elements in device Example\+: Jagged vector with sizes = \{3,2,1,...\} Returns\+: \{\mbox{[}0,0\mbox{]}, \mbox{[}0,1\mbox{]}, \mbox{[}0,2\mbox{]}, \mbox{[}1,0\mbox{]}, \mbox{[}1,1\mbox{]}, \mbox{[}2,0\mbox{]}, ...\}

This algorithm returns a buffer which is not necessarily filled yet. A synchronisation statement is required before or destroying this buffer.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em sizes} & The sizes of the jagged vector \\
\hline
 & {\em copy} & A \char`\"{}copy object\char`\"{} capable of dealing with the view \\
\hline
 & {\em mr} & The memory resource to create the buffer with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector buffer of prefix\+\_\+sum element 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacetraccc_1_1cuda_aaf5709adc5f8f4e3ee52b7eef97a87f8}\label{namespacetraccc_1_1cuda_aaf5709adc5f8f4e3ee52b7eef97a87f8}} 
\index{traccc::cuda@{traccc::cuda}!make\_prefix\_sum\_buff@{make\_prefix\_sum\_buff}}
\index{make\_prefix\_sum\_buff@{make\_prefix\_sum\_buff}!traccc::cuda@{traccc::cuda}}
\doxysubsubsection{\texorpdfstring{make\_prefix\_sum\_buff()}{make\_prefix\_sum\_buff()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily vecmem\+::data\+::vector\+\_\+buffer$<$\mbox{\hyperlink{namespacetraccc_1_1device_aec5610a925cef95697843cc4e8b38bcb}{device\+::prefix\+\_\+sum\+\_\+element\+\_\+t}}$>$ traccc\+::cuda\+::make\+\_\+prefix\+\_\+sum\+\_\+buff (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacetraccc_1_1device_ade298ff55a1bdb496e412262cdb66433}{device\+::prefix\+\_\+sum\+\_\+size\+\_\+t}} $>$ \&}]{sizes,  }\item[{vecmem\+::copy \&}]{copy,  }\item[{const \mbox{\hyperlink{structtraccc_1_1memory__resource}{traccc\+::memory\+\_\+resource}} \&}]{mr,  }\item[{const \mbox{\hyperlink{classtraccc_1_1cuda_1_1stream}{stream}} \&}]{str }\end{DoxyParamCaption})}

Function that returns vector of prefix\+\_\+sum\+\_\+element\+\_\+t for accessing a jagged vector\textquotesingle{}s elements in device Example\+: Jagged vector with sizes = \{3,2,1,...\} Returns\+: \{\mbox{[}0,0\mbox{]}, \mbox{[}0,1\mbox{]}, \mbox{[}0,2\mbox{]}, \mbox{[}1,0\mbox{]}, \mbox{[}1,1\mbox{]}, \mbox{[}2,0\mbox{]}, ...\}

This algorithm returns a buffer which is not necessarily filled yet. A synchronisation statement is required before or destroying this buffer.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em sizes} & The sizes of the jagged vector \\
\hline
 & {\em copy} & A \char`\"{}copy object\char`\"{} capable of dealing with the view \\
\hline
 & {\em mr} & The memory resource to create the buffer with \\
\hline
 & {\em str} & The C\+U\+DA stream to create the buffer with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector buffer of prefix\+\_\+sum element 
\end{DoxyReturn}
